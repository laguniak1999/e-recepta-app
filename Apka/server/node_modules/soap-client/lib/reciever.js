var
   	 sax = require("sax")
    , EventEmitter = require('events').EventEmitter
;

/*
				var xml = sax.createStream( true );
				var xmlns = [];
				var data = { };
				var curTag = null;
				
				function getXmlNs( n ) {
					if( !n ) n = '';
					
					for( var i = 0; i < xmlns.length; i ++ ) if( xmlns[i] ) {
						if( xmlns[i][n] ) return xmlns[i][n];
					}
					return null;
				}
				
				function parseTag( tag ) {
					if( tag ) {
						if( typeof( tag ) != 'object' ) tag = { name : tag + '' };
						var m;
						if( m = tag.name.match( /^([^:]+):(.*)$/ )) {
							tag.localName = m[2];
							tag.xmlns = getXmlNs( m[1] );
						} else {
							tag.localName = tag.name;
							tag.xmlns = getXmlNs( '' );
						}
					}
					return tag;
				}
				
				var text = null, cur, targetN, target;
				
				function placeVal( target, n, t, v ) {
					if( typeof( target[n] ) != 'undefined' ) {
						if( target[n] instanceof Array ) {
							target[n].push( v );
						} else {
							throw new Error( "Invalid response" );
						}
					} else {
						if( t.maxOccurs > 1 || t.maxOccurs == 'unbounded' ) {
							target[n] = [ v ];
						} else {
							target[n] = v;
						}
					}

					return v;
				}
				
				xml.on( 'opentag', function( t ) {
					var xmlnsT = null;
					for( var i in t.attributes ) if( i.match( /^xmlns/ )) {
						if( !xmlnsT ) xmlnsT = { };
						xmlnsT[i.replace(/^xmlns(:|$)/, '' )] = t.attributes[i];
					}
					xmlns.unshift( xmlnsT );
					
					parseTag( t )
					
					
					if( curTag && curTag.length > 0 ) {
						if( t.xmlns != paramsNs ) {
							ret.emit( 'error', new Error( "Invalid response - onvalid namespace" ));
							curTag = null;
						} else if( curTag[0].t[t.localName] ) try {
							cur = curTag[0].t[t.localName], target = curTag[0].target, targetN = t.localName;
							
							if( cur.complexType ) {
								curTag.unshift({ t : types[cur.complexType], target : placeVal( target, targetN, cur, { }) });
							} else if( cur.baseType ) {
								text = '';
							} else {
								throw new Error( "Internal error" );
							}
							
						} catch( e ) {
							ret.emit( 'error', e );
							curTag = null;
						} else {
							ret.emit( 'error', new Error( "Invalid response - tag on bad place " + t.localName + " in " + JSON.stringify( curTag[0] )));
							curTag = null;
						}
					} else if( t.localName == 'Body' && t.xmlns == 'http://schemas.xmlsoap.org/soap/envelope/' ) {
						curTag = [];
						var td = { };
						td[output.complexType] = { minOccurs : 1, maxOccurs : 1, complexType : output.complexType };
						curTag.unshift({ t : td, target : data });
					}
				});
				
				xml.on( 'text', function( t ) {
					if( text != null ) text += t;
					
				});
				
				xml.on( 'closetag', function( n ) {
					if( text != null ) {
					} else {
						if( curTag ) curTag.shift( );
					}
					text = null;
				});
				

                */
module.exports = function (wsdl, messageType) {

    return function (stream, callback) {
        var xmle = require('./xml')(stream), reader = [], tReciever = null, tx, out = {};

        function typeValidator(type, placeVal) {
            if (type.baseType) {
                tReciever = function (text) {
                    var v = undefined;
                    switch (type.baseType) {
                        case 'int':
                            v = parseInt(text);
                            if (isNaN(v)) throw new Error(p + " isn't Integer");
                            break;
                        case 'string':
                            v = text;
                            break;
                        case 'float':
                            v = parseFloat(text);
                            if (isNaN(v)) throw new Error(p + " isn't Float");
                            break;
                        case 'base64Binary':
                            v = new Buffer(text, 'base64');
                            break;
                        case 'boolean':
                            v = text == 'true';
                            break;
                        default:
                            console.log(text);
                    }
                    if (v != undefined && v != null) {
                        placeVal(v)
                    }
                }
            } else if( wsdl.types[type.complexType] ){
                var t = wsdl.types[type.complexType];
                var data = {};
                placeVal( data );

                return function (tag) {
                    if (!t[tag.localName]) return function () { };

                    var tCur = t[tag.localName];
                    if (tCur.maxOccurs > 1 || tCur.maxOccurs == 'unbounded') {
                        if (!data[tag]) data[tag] = [];
                        return typeValidator(tCur, function (val) { data[tag].push(val)});
                    } else {
                        if (!data[tag]) return typeValidator(tCur, function (val) { data[tag] = val });
                    }
                }
                
            } else return function () { }
        }

        reader.unshift(function (tag) {
            if (tag.xmlns != wsdl.parametersNs) return;
            if (!wsdl.messages[tag.localName]) return;

            var m = wsdl.messages[tag.localName];
            return function (tag) {
                var mPartO;
                m.forEach(function (mPart) {
                    if( mPartO ) return;

                    if( tag.localName == mPart.name ) mPartO = mPart;
                });

                if( mPartO ) return typeValidator(mPartO, function (val) {
                    out[mPartO.name] = val;
                }); else return function () { }
            }
            console.log(tag);
        });

        xmle.on('opentag', function (tag) {
            var r = reader[0];
            tx = '';
            if (!r) return;

            r = r(tag);
            if (!r) r = reader[0];
            reader.unshift(r);
        });

        xmle.on('text', function (text) {
            if (tReciever) tx += text;
        });

        xmle.on('closetag', function (tag) {
            reader.shift();
            if (tReciever) tReciever(tx);
            tReciever = null;
        });

        xmle.on('end', function () {
            callback(null, out);
        });
    }
}