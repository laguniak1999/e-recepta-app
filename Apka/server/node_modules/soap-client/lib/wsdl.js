function wsdl() {
    this.types = {};
    this.messages = {};
    this.ports = {};
    this.bindings = {};
    this.addresses = {};
}

var XMLNS = {
    wsdl : "http://schemas.xmlsoap.org/wsdl/",
    xmls: "http://www.w3.org/2001/XMLSchema",
    soap: "http://schemas.xmlsoap.org/wsdl/soap/",
    soap12: "http://schemas.xmlsoap.org/wsdl/soap12/",
    soapHttp: "http://schemas.xmlsoap.org/soap/http"
}

module.exports = function (stream, callback) {
    var xmle = require('./xml')(stream);

    var reader = [], out = new wsdl();

    function parseType(target, type) {
        var type = xmle.parseTag(type)
        if (type.xmlns == XMLNS.xmls) {
            target.baseType = type.localName;
        } else if (type.xmlns == out.parametersNs) {
            target.complexType = type.localName;
        }

        return target;
    }

    function typeReader(tag) {
        if (tag.xmlns != XMLNS.xmls) return;

        if (tag.localName == 'schema') out.parametersNs = tag.attributes.targetNamespace;
        if (tag.localName == 'element' || tag.localName == 'complexType') {
            var t = out.types[tag.attributes.name] = {};

            return function (tag) {
                if (tag.localName != 'element') return;

                var tr = {
                    minOccurs: tag.attributes.minOccurs || 0,
                    maxOccurs: tag.attributes.maxOccurs || 1,
                    name: tag.attributes.name
                };
                parseType(tr, tag.attributes.type);

                t[tag.attributes.name] = tr;

            }

        }

    }

    reader.unshift(function (tag) {
        if (tag.xmlns != XMLNS.wsdl) return;

        if (tag.localName == 'definitions') out.targetNs = tag.attributes.targetNamespace;
        if (tag.localName == 'types') return typeReader;
        if (tag.localName == 'message') {
            var m = out.messages[tag.attributes.name] = [];

            return function (tag) {
                if (tag.xmlns != XMLNS.wsdl) return;
                if (tag.localName != 'part') return;

                var t = tag.attributes.element || tag.attributes.type;
                var tdata = {};
                if( tag.attributes.name ) tdata.name = tag.attributes.name;

                m.push(parseType(tdata, t));
            }
        }

        if (tag.localName == 'portType') {
            var p = out.ports[tag.attributes.name] = { };

            return function (tag) {
                if (tag.xmlns != XMLNS.wsdl) return;
                if (tag.localName != 'operation' ) return;

                var op = p[tag.attributes.name] = {};

                return function (tag) {
                    if (tag.xmlns != XMLNS.wsdl) return;
                    if (tag.localName == 'output') op.output = parseType({}, tag.attributes.message).complexType;
                    if (tag.localName == 'input') op.input = parseType({}, tag.attributes.message).complexType;
                };
            }
        }

        if (tag.localName == 'binding') {
            var b = out.bindings[tag.attributes.name] = {};
            var t = xmle.parseTag(tag.attributes.type);
            if (t.xmlns != out.targetNs) return;

            b.type = t.localName;
            var operations = b.operations = {};
            b.transports = [];

            return function (tag) {
                if (tag.localName == 'binding') {
                    var transport = {};
                    b.transports.push(transport);

                    if (tag.attributes.transport == XMLNS.soapHttp) {
                        transport.protocol = 'http';
                    }

                    if (tag.xmlns == XMLNS.soap12) {
                        transport.soap = 12;
                    } else if (tag.xmlns == XMLNS.soap) {
                        transport.soap = 10;
                    }
                }

                if (tag.localName == 'operation' && tag.xmlns == XMLNS.wsdl) {
                    var o = operations[tag.attributes.name] = {};

                    return function (tag) {
                        if (tag.localName == 'operation') o.action = tag.attributes.soapAction;
                    }
                }
            }
        }

        if (tag.localName == 'port') {
            var b = xmle.parseTag( tag.attributes.binding );
            if( b.xmlns != out.targetNs ) return ;
            b = b.localName;
					
            var a = out.addresses[tag.attributes.name] = {
                binding : b,
                urls : []
            }
					
            return function( tag ) { 
                if( tag.localName == 'address' ) { 
                    var url = { };
                    if( tag.xmlns == XMLNS.soap12 ) {
                        url.soap = 12;
                    } else if( tag.xmlns == XMLNS.soap ) {
                        url.soap = 10;
                    }
                                    
                    url.location = tag.attributes.location;
                    a.urls.push( url );
                }
            };
        
        }
    });

    xmle.on('opentag', function (tag) {
        var r = reader[0];
        if (!r) return;

        r = r(tag);
        if (!r) r = reader[0];
        reader.unshift(r);
    });

    xmle.on('closetag', function (tag) {
        reader.shift();
    });

    xmle.on('end', function () {
        callback( null, out );
    });
}

/*
				
xml.on( 'end', function( ) {
    // 1. Merge URLs and bindings
    for( var i in addresses ) {
        var a = addresses[i];
        var b = bindings[a.binding];
        if( b ) {
            b.urls = [];
            a.urls.forEach( function( u ) {
                if( u.soap == b.transport.soap ) b.urls.push( u );
            })
        } else {
            ret.emit( "warning", "There is no binding for service port " + i );
        }
    }
					
    // 2. Merge bindings and ports
    for( var i in bindings ) {
        var b = bindings[i]; var p = ports[b.type];
        if( p ) {
            // TODO: Choose best binding.
            p.bindings.push( b );
        }
						
    }
					
    // 3. Create method calls and map types
    for( var i in ports ) {
        var p = ports[i];
						
        for( var j in p.operations ) {
            var o = p.operations[j];
            var bnd = null;
							
            p.bindings.forEach( function( b ) {
                if( bnd ) return;
                if( b.operations[j] ) {
                    bnd = {
                        action : b.operations[j].action,
                        url : b.urls[0].location,
                        protocol : b.transport.protocol
                    }
                }
            });

            if( bnd ) {
                ( function( msgIn, msgOut ) {
                    ret[j] = ( function( j, o, bnd ) {
                        return function( params ) {
                            return soapRequest( bnd.url, bnd.protocol, bnd.action, params, msgIn, msgOut, types, parametersNs );
                        }
                    })( j, o, bnd );
                })( messages[o.input.complexType][0], messages[o.output.complexType][0] )
								
            } else {
                ret.emit( "warning", "Message " + j + " have no bindings" );
            }
        }
    }
					
    ret.emit( 'initialized' );
});

*/