
var http = require( 'http' ),
	https = require( 'https' ),
	EventEmitter = require('events').EventEmitter,
	url = require( 'url' );

var request = {
	'http' : http.request,
	'https' : https.request
};

module.exports = function( wsdl, options ) {
    options = options || {};
    var ret = new EventEmitter();
	
	var wsdlUrl = url.parse(wsdl);
	var r = request[wsdlUrl.protocol.replace( /[^a-z]/g, '')];

	if (options.proxy) {
	    options.proxy = url.parse(options.proxy);

	    r = request[options.proxy.protocol.replace(/[^a-z]/g, '')];

	    wsdlUrl = options.proxy;
	    wsdlUrl.path = wsdl;
	}

	if (options.authorization) if (options.authorization.basic) {
	    with (options.authorization.basic) wsdlUrl.auth = user + ':' + password;
	}

	if( r ) {
	    r = r(wsdlUrl, function (res) {
	        if( res.statusCode != 200 ) {
				ret.emit( 'error', new Error( "Server responded with error code " + res.statusCode ));
	        } else {
	            require('./lib/wsdl')(res, function (err, wsdl) {
	                for (var i in wsdl.ports) {
	                    var p = wsdl.ports[i];

	                    for (var fName in p) {
	                        var fInfo = p[fName], f = {}, soapAction, url;

	                        for (var bName in wsdl.bindings) with (wsdl.bindings[bName]) if (type == i) {
	                            if (!operations[fName]) continue;

	                            transports.forEach(function (t) {
	                                if (t.protocol != 'http') return;
	                                if (soapAction) return;

	                                soapAction = operations[fName].action;
	                            });

	                            break;
	                        }

	                        if( !soapAction ) continue;
	                        for (var addrN in wsdl.addresses) with (wsdl.addresses[addrN]) if (binding == bName) {
	                            urls.forEach( function( u ) {
	                                if (url) return;

	                                url = u.location;
	                            });
	                        }

	                        ret[fName] = require('./lib/function')(wsdl, soapAction, url, fName, fInfo, options);
	                        ret.emit('initialized');
	                    }
	                }
	            });
			}
		});
		
		r.on('error', function (err) {
		    ret.emit('error', err);
		});

		r.end( );
	} else {
		setTimeout( function( ) {
			ret.emit( 'error', new Error( "Unknown protocol for WSDL" ));
		}, 1 );
	}
	
	ret.call = function( method ) {
		if( typeof( ret[method] ) == 'undefined' ) throw new Error( "Method " + method  + " not found" );
		
		Array.prototype.shift.call(arguments);
		return ret[method].apply(this, arguments);
	}
	
	return ret;
}