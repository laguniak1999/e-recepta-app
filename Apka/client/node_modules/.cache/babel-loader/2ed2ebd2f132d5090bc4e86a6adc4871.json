{"ast":null,"code":"import { hp2Builder } from '@selderee/plugin-htmlparser2';\nimport { parseDocument } from 'htmlparser2';\nimport { DecisionTree } from 'selderee';\nimport merge from 'deepmerge';\nimport { render } from 'dom-serializer';\n/**\n * Make a recursive function that will only run to a given depth\n * and switches to an alternative function at that depth. \\\n * No limitation if `n` is `undefined` (Just wraps `f` in that case).\n *\n * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.\n * @param   { Function }           f   Function that accepts recursive callback as the first argument.\n * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.\n * @returns { Function }\n */\n\nfunction limitedDepthRecursive(n, f) {\n  let g = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => undefined;\n\n  if (n === undefined) {\n    const f1 = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return f(f1, ...args);\n    };\n\n    return f1;\n  }\n\n  if (n >= 0) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return f(limitedDepthRecursive(n - 1, f, g), ...args);\n    };\n  }\n\n  return g;\n}\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from each side.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */\n\n\nfunction trimCharacter(str, char) {\n  let start = 0;\n  let end = str.length;\n\n  while (start < end && str[start] === char) {\n    ++start;\n  }\n\n  while (end > start && str[end - 1] === char) {\n    --end;\n  }\n\n  return start > 0 || end < str.length ? str.substring(start, end) : str;\n}\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from the end only.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */\n\n\nfunction trimCharacterEnd(str, char) {\n  let end = str.length;\n\n  while (end > 0 && str[end - 1] === char) {\n    --end;\n  }\n\n  return end < str.length ? str.substring(0, end) : str;\n}\n/**\n * Return a new string will all characters replaced with unicode escape sequences.\n * This extreme kind of escaping can used to be safely compose regular expressions.\n *\n * @param { string } str A string to escape.\n * @returns { string } A string of unicode escape sequences.\n */\n\n\nfunction unicodeEscape(str) {\n  return str.replace(/[\\s\\S]/g, c => '\\\\u' + c.charCodeAt().toString(16).padStart(4, '0'));\n}\n/**\n * Deduplicate an array by a given key callback.\n * Item properties are merged recursively and with the preference for last defined values.\n * Of items with the same key, merged item takes the place of the last item,\n * others are omitted.\n *\n * @param { any[] } items An array to deduplicate.\n * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.\n * @returns { any[] }\n */\n\n\nfunction mergeDuplicatesPreferLast(items, getKey) {\n  const map = new Map();\n\n  for (let i = items.length; i-- > 0;) {\n    const item = items[i];\n    const key = getKey(item);\n    map.set(key, map.has(key) ? merge(item, map.get(key), {\n      arrayMerge: overwriteMerge$1\n    }) : item);\n  }\n\n  return [...map.values()].reverse();\n}\n\nconst overwriteMerge$1 = (acc, src, options) => [...src];\n/**\n * Get a nested property from an object.\n *\n * @param   { object }   obj  The object to query for the value.\n * @param   { string[] } path The path to the property.\n * @returns { any }\n */\n\n\nfunction get(obj, path) {\n  for (const key of path) {\n    if (!obj) {\n      return undefined;\n    }\n\n    obj = obj[key];\n  }\n\n  return obj;\n}\n/**\n * Convert a number into alphabetic sequence representation (Sequence without zeroes).\n *\n * For example: `a, ..., z, aa, ..., zz, aaa, ...`.\n *\n * @param   { number } num              Number to convert. Must be >= 1.\n * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.\n * @param   { number } [base = 26]      Number of characters in the sequence.\n * @returns { string }\n */\n\n\nfunction numberToLetterSequence(num) {\n  let baseChar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'a';\n  let base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 26;\n  const digits = [];\n\n  do {\n    num -= 1;\n    digits.push(num % base);\n    num = num / base >> 0; // quick `floor`\n  } while (num > 0);\n\n  const baseCode = baseChar.charCodeAt(0);\n  return digits.reverse().map(n => String.fromCharCode(baseCode + n)).join('');\n}\n\nconst I = ['I', 'X', 'C', 'M'];\nconst V = ['V', 'L', 'D'];\n/**\n * Convert a number to it's Roman representation. No large numbers extension.\n *\n * @param   { number } num Number to convert. `0 < num <= 3999`.\n * @returns { string }\n */\n\nfunction numberToRoman(num) {\n  return [...(num + '')].map(n => +n).reverse().map((v, i) => v % 5 < 4 ? (v < 5 ? '' : V[i]) + I[i].repeat(v % 5) : I[i] + (v < 5 ? V[i] : I[i + 1])).reverse().join('');\n}\n/**\n * Helps to build text from words.\n */\n\n\nclass InlineTextBuilder {\n  /**\n   * Creates an instance of InlineTextBuilder.\n   *\n   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.\n   *\n   * @param { Options } options           HtmlToText options.\n   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.\n   */\n  constructor(options) {\n    let maxLineLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    /** @type { string[][] } */\n    this.lines = [];\n    /** @type { string[] }   */\n\n    this.nextLineWords = [];\n    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;\n    this.nextLineAvailableChars = this.maxLineLength;\n    this.wrapCharacters = get(options, ['longWordSplit', 'wrapCharacters']) || [];\n    this.forceWrapOnLimit = get(options, ['longWordSplit', 'forceWrapOnLimit']) || false;\n    this.stashedSpace = false;\n    this.wordBreakOpportunity = false;\n  }\n  /**\n   * Add a new word.\n   *\n   * @param { string } word A word to add.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */\n\n\n  pushWord(word) {\n    let noWrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (this.nextLineAvailableChars <= 0 && !noWrap) {\n      this.startNewLine();\n    }\n\n    const isLineStart = this.nextLineWords.length === 0;\n    const cost = word.length + (isLineStart ? 0 : 1);\n\n    if (cost <= this.nextLineAvailableChars || noWrap) {\n      // Fits into available budget\n      this.nextLineWords.push(word);\n      this.nextLineAvailableChars -= cost;\n    } else {\n      // Does not fit - try to split the word\n      // The word is moved to a new line - prefer to wrap between words.\n      const [first, ...rest] = this.splitLongWord(word);\n\n      if (!isLineStart) {\n        this.startNewLine();\n      }\n\n      this.nextLineWords.push(first);\n      this.nextLineAvailableChars -= first.length;\n\n      for (const part of rest) {\n        this.startNewLine();\n        this.nextLineWords.push(part);\n        this.nextLineAvailableChars -= part.length;\n      }\n    }\n  }\n  /**\n   * Pop a word from the currently built line.\n   * This doesn't affect completed lines.\n   *\n   * @returns { string }\n   */\n\n\n  popWord() {\n    const lastWord = this.nextLineWords.pop();\n\n    if (lastWord !== undefined) {\n      const isLineStart = this.nextLineWords.length === 0;\n      const cost = lastWord.length + (isLineStart ? 0 : 1);\n      this.nextLineAvailableChars += cost;\n    }\n\n    return lastWord;\n  }\n  /**\n   * Concat a word to the last word already in the builder.\n   * Adds a new word in case there are no words yet in the last line.\n   *\n   * @param { string } word A word to be concatenated.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */\n\n\n  concatWord(word) {\n    let noWrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {\n      this.pushWord(word, noWrap);\n      this.wordBreakOpportunity = false;\n    } else {\n      const lastWord = this.popWord();\n      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);\n    }\n  }\n  /**\n   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.\n   *\n   * @param { number } n Number of line breaks that will be added to the resulting string.\n   */\n\n\n  startNewLine() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    this.lines.push(this.nextLineWords);\n\n    if (n > 1) {\n      this.lines.push(...Array.from({\n        length: n - 1\n      }, () => []));\n    }\n\n    this.nextLineWords = [];\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n  /**\n   * No words in this builder.\n   *\n   * @returns { boolean }\n   */\n\n\n  isEmpty() {\n    return this.lines.length === 0 && this.nextLineWords.length === 0;\n  }\n\n  clear() {\n    this.lines.length = 0;\n    this.nextLineWords.length = 0;\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n  /**\n   * Join all lines of words inside the InlineTextBuilder into a complete string.\n   *\n   * @returns { string }\n   */\n\n\n  toString() {\n    return [...this.lines, this.nextLineWords].map(words => words.join(' ')).join('\\n');\n  }\n  /**\n   * Split a long word up to fit within the word wrap limit.\n   * Use either a character to split looking back from the word wrap limit,\n   * or truncate to the word wrap limit.\n   *\n   * @param   { string }   word Input word.\n   * @returns { string[] }      Parts of the word.\n   */\n\n\n  splitLongWord(word) {\n    const parts = [];\n    let idx = 0;\n\n    while (word.length > this.maxLineLength) {\n      const firstLine = word.substring(0, this.maxLineLength);\n      const remainingChars = word.substring(this.maxLineLength);\n      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);\n\n      if (splitIndex > -1) {\n        // Found a character to split on\n        word = firstLine.substring(splitIndex + 1) + remainingChars;\n        parts.push(firstLine.substring(0, splitIndex + 1));\n      } else {\n        // Not found a character to split on\n        idx++;\n\n        if (idx < this.wrapCharacters.length) {\n          // There is next character to try\n          word = firstLine + remainingChars;\n        } else {\n          // No more characters to try\n          if (this.forceWrapOnLimit) {\n            parts.push(firstLine);\n            word = remainingChars;\n\n            if (word.length > this.maxLineLength) {\n              continue;\n            }\n          } else {\n            word = firstLine + remainingChars;\n          }\n\n          break;\n        }\n      }\n    }\n\n    parts.push(word); // Add remaining part to array\n\n    return parts;\n  }\n\n}\n/* eslint-disable max-classes-per-file */\n\n\nclass StackItem {\n  constructor() {\n    let next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.next = next;\n  }\n\n  getRoot() {\n    return this.next ? this.next : this;\n  }\n\n}\n\nclass BlockStackItem extends StackItem {\n  constructor(options) {\n    let next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let leadingLineBreaks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let maxLineLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    super(next);\n    this.leadingLineBreaks = leadingLineBreaks;\n    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);\n    this.rawText = '';\n    this.stashedLineBreaks = 0;\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n\n}\n\nclass ListStackItem extends BlockStackItem {\n  constructor(options) {\n    let next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let {\n      interRowLineBreaks = 1,\n      leadingLineBreaks = 2,\n      maxLineLength = undefined,\n      maxPrefixLength = 0,\n      prefixAlign = 'left'\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(options, next, leadingLineBreaks, maxLineLength);\n    this.maxPrefixLength = maxPrefixLength;\n    this.prefixAlign = prefixAlign;\n    this.interRowLineBreaks = interRowLineBreaks;\n  }\n\n}\n\nclass ListItemStackItem extends BlockStackItem {\n  constructor(options) {\n    let next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let {\n      leadingLineBreaks = 1,\n      maxLineLength = undefined,\n      prefix = ''\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(options, next, leadingLineBreaks, maxLineLength);\n    this.prefix = prefix;\n  }\n\n}\n\nclass TableStackItem extends StackItem {\n  constructor() {\n    let next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(next);\n    this.rows = [];\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n\n}\n\nclass TableRowStackItem extends StackItem {\n  constructor() {\n    let next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(next);\n    this.cells = [];\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n\n}\n\nclass TableCellStackItem extends StackItem {\n  constructor(options) {\n    let next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let maxColumnWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    super(next);\n    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);\n    this.rawText = '';\n    this.stashedLineBreaks = 0;\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n\n}\n\nclass TransformerStackItem extends StackItem {\n  constructor() {\n    let next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let transform = arguments.length > 1 ? arguments[1] : undefined;\n    super(next);\n    this.transform = transform;\n  }\n\n}\n\nfunction charactersToCodes(str) {\n  return [...str].map(c => '\\\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join('');\n}\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */\n\n\nclass WhitespaceProcessor {\n  /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */\n  constructor(options) {\n    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\\n/g, '') : options.whitespaceCharacters;\n    const whitespaceCodes = charactersToCodes(this.whitespaceChars);\n    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);\n    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);\n    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);\n    this.newlineOrNonWhitespaceRe = new RegExp(`(\\\\n|[^\\\\n${whitespaceCodes}])`, 'g');\n    this.newlineOrNonNewlineStringRe = new RegExp(`(\\\\n|[^\\\\n]+)`, 'g');\n\n    if (options.preserveNewlines) {\n      const wordOrNewlineRe = new RegExp(`\\\\n|[^\\\\n${whitespaceCodes}]+`, 'gm');\n      /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.\n       */\n\n      this.shrinkWrapAdd = function (text, inlineTextBuilder) {\n        let transform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : str => str;\n        let noWrap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        if (!text) {\n          return;\n        }\n\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordOrNewlineRe.exec(text);\n\n        if (m) {\n          anyMatch = true;\n\n          if (m[0] === '\\n') {\n            inlineTextBuilder.startNewLine();\n          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n          }\n\n          while ((m = wordOrNewlineRe.exec(text)) !== null) {\n            if (m[0] === '\\n') {\n              inlineTextBuilder.startNewLine();\n            } else {\n              inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n            }\n          }\n        }\n\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text); // No need to stash a space in case last added item was a new line,\n        // but that won't affect anything later anyway.\n      };\n    } else {\n      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, 'g');\n\n      this.shrinkWrapAdd = function (text, inlineTextBuilder) {\n        let transform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : str => str;\n        let noWrap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        if (!text) {\n          return;\n        }\n\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordRe.exec(text);\n\n        if (m) {\n          anyMatch = true;\n\n          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n          }\n\n          while ((m = wordRe.exec(text)) !== null) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          }\n        }\n\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n      };\n    }\n  }\n  /**\n   * Add text with only minimal processing.\n   * Everything between newlines considered a single word.\n   * No whitespace is trimmed.\n   * Not affected by preserveNewlines option - `\\n` always starts a new line.\n   *\n   * `noWrap` argument is `true` by default - this won't start a new line\n   * even if there is not enough space left in the current line.\n   *\n   * @param { string }            text              Input text.\n   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.\n   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.\n   */\n\n\n  addLiteral(text, inlineTextBuilder) {\n    let noWrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (!text) {\n      return;\n    }\n\n    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n    let anyMatch = false;\n    let m = this.newlineOrNonNewlineStringRe.exec(text);\n\n    if (m) {\n      anyMatch = true;\n\n      if (m[0] === '\\n') {\n        inlineTextBuilder.startNewLine();\n      } else if (previouslyStashedSpace) {\n        inlineTextBuilder.pushWord(m[0], noWrap);\n      } else {\n        inlineTextBuilder.concatWord(m[0], noWrap);\n      }\n\n      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {\n        if (m[0] === '\\n') {\n          inlineTextBuilder.startNewLine();\n        } else {\n          inlineTextBuilder.pushWord(m[0], noWrap);\n        }\n      }\n    }\n\n    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;\n  }\n  /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n\n\n  testLeadingWhitespace(text) {\n    return this.leadingWhitespaceRe.test(text);\n  }\n  /**\n   * Test whether the given text ends with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n\n\n  testTrailingWhitespace(text) {\n    return this.trailingWhitespaceRe.test(text);\n  }\n  /**\n   * Test whether the given text contains any non-whitespace characters.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n\n\n  testContainsWords(text) {\n    return !this.allWhitespaceOrEmptyRe.test(text);\n  }\n  /**\n   * Return the number of newlines if there are no words.\n   *\n   * If any word is found then return zero regardless of the actual number of newlines.\n   *\n   * @param   { string }  text  Input string.\n   * @returns { number }\n   */\n\n\n  countNewlinesNoWords(text) {\n    this.newlineOrNonWhitespaceRe.lastIndex = 0;\n    let counter = 0;\n    let match;\n\n    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {\n      if (match[0] === '\\n') {\n        counter++;\n      } else {\n        return 0;\n      }\n    }\n\n    return counter;\n  }\n\n}\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\n\n\nclass BlockTextBuilder {\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.\n   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.\n   */\n  constructor(options, picker) {\n    let metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    this.options = options;\n    this.picker = picker;\n    this.metadata = metadata;\n    this.whitespaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n\n    this._wordTransformer = undefined;\n  }\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n\n\n  pushWordTransform(wordTransform) {\n    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n  }\n  /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */\n\n\n  popWordTransform() {\n    if (!this._wordTransformer) {\n      return undefined;\n    }\n\n    const transform = this._wordTransformer.transform;\n    this._wordTransformer = this._wordTransformer.next;\n    return transform;\n  }\n  /**\n   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.\n   */\n\n\n  startNoWrap() {\n    this._stackItem.isNoWrap = true;\n  }\n  /**\n   * Return automatic wrapping to behavior defined by options.\n   */\n\n\n  stopNoWrap() {\n    this._stackItem.isNoWrap = false;\n  }\n  /** @returns { (str: string) => string } */\n\n\n  _getCombinedWordTransformer() {\n    const wt = this._wordTransformer ? str => applyTransformer(str, this._wordTransformer) : undefined;\n    const ce = this.options.encodeCharacters;\n    return wt ? ce ? str => ce(wt(str)) : wt : ce;\n  }\n\n  _popStackItem() {\n    const item = this._stackItem;\n    this._stackItem = item.next;\n    return item;\n  }\n  /**\n   * Add a line break into currently built block.\n   */\n\n\n  addLineBreak() {\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += '\\n';\n    } else {\n      this._stackItem.inlineTextBuilder.startNewLine();\n    }\n  }\n  /**\n   * Allow to break line in case directly following text will not fit.\n   */\n\n\n  addWordBreakOpportunity() {\n    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {\n      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n    }\n  }\n  /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object } [param1]\n   * Object holding the parameters of the operation.\n   *\n   * @param { boolean } [param1.noWordTransform]\n   * Ignore word transformers if there are any.\n   * Don't encode characters as well.\n   * (Use this for things like URL addresses).\n   */\n\n\n  addInline(str) {\n    let {\n      noWordTransform = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (str.length === 0 || // empty string\n    this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant\n    !this.whitespaceProcessor.testContainsWords(str) // no words to add\n    ) {\n      return;\n    }\n\n    if (this.options.preserveNewlines) {\n      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);\n\n      if (newlinesNumber > 0) {\n        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber); // keep stashedLineBreaks unchanged\n\n\n        return;\n      }\n    }\n\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n\n    this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);\n    this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n  }\n  /**\n   * Add a string inline into the currently built block.\n   *\n   * Use this for markup elements that don't have to adhere\n   * to text layout rules.\n   *\n   * @param { string } str Text to add.\n   */\n\n\n  addLiteral(str) {\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n\n    if (str.length === 0) {\n      return;\n    }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n\n    this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);\n    this._stackItem.stashedLineBreaks = 0;\n  }\n  /**\n   * Start building a new block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any preceding block.\n   *\n   * @param { number }  [param0.reservedLineLength]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [param0.isPre]\n   * Should HTML whitespace be preserved inside this block.\n   */\n\n\n  openBlock() {\n    let {\n      leadingLineBreaks = 1,\n      reservedLineLength = 0,\n      isPre = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n    this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);\n\n    if (isPre) {\n      this._stackItem.isPre = true;\n    }\n  }\n  /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [param0.blockTransform]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   */\n\n\n  closeBlock() {\n    let {\n      trailingLineBreaks = 1,\n      blockTransform = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const block = this._popStackItem();\n\n    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);\n    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n  }\n  /**\n   * Start building a new list.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.maxPrefixLength]\n   * Length of the longest list item prefix.\n   * If not supplied or too small then list items won't be aligned properly.\n   *\n   * @param { 'left' | 'right' } [param0.prefixAlign]\n   * Specify how prefixes of different lengths have to be aligned\n   * within a column.\n   *\n   * @param { number } [param0.interRowLineBreaks]\n   * Minimum number of line breaks between list items.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any preceding block.\n   */\n\n\n  openList() {\n    let {\n      maxPrefixLength = 0,\n      prefixAlign = 'left',\n      interRowLineBreaks = 1,\n      leadingLineBreaks = 2\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._stackItem = new ListStackItem(this.options, this._stackItem, {\n      interRowLineBreaks: interRowLineBreaks,\n      leadingLineBreaks: leadingLineBreaks,\n      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,\n      maxPrefixLength: maxPrefixLength,\n      prefixAlign: prefixAlign\n    });\n  }\n  /**\n   * Start building a new list item.\n   *\n   * @param {object} param0\n   * Object holding the parameters of the list item.\n   *\n   * @param { string } [param0.prefix]\n   * Prefix for this list item (item number, bullet point, etc).\n   */\n\n\n  openListItem() {\n    let {\n      prefix = ''\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!(this._stackItem instanceof ListStackItem)) {\n      throw new Error('Can\\'t add a list item to something that is not a list! Check the formatter.');\n    }\n\n    const list = this._stackItem;\n    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);\n    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);\n    this._stackItem = new ListItemStackItem(this.options, list, {\n      prefix: prefix,\n      maxLineLength: maxLineLength,\n      leadingLineBreaks: list.interRowLineBreaks\n    });\n  }\n  /**\n   * Finalize currently built list item, add it's content to the parent list.\n   */\n\n\n  closeListItem() {\n    const listItem = this._popStackItem();\n\n    const list = listItem.next;\n    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);\n    const spacing = '\\n' + ' '.repeat(prefixLength);\n    const prefix = list.prefixAlign === 'right' ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);\n    const text = prefix + getText(listItem).replace(/\\n/g, spacing);\n    addText(list, text, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));\n  }\n  /**\n   * Finalize currently built list, add it's content to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any following block.\n   */\n\n\n  closeList() {\n    let {\n      trailingLineBreaks = 2\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const list = this._popStackItem();\n\n    const text = getText(list);\n\n    if (text) {\n      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n  /**\n   * Start building a table.\n   */\n\n\n  openTable() {\n    this._stackItem = new TableStackItem(this._stackItem);\n  }\n  /**\n   * Start building a table row.\n   */\n\n\n  openTableRow() {\n    if (!(this._stackItem instanceof TableStackItem)) {\n      throw new Error('Can\\'t add a table row to something that is not a table! Check the formatter.');\n    }\n\n    this._stackItem = new TableRowStackItem(this._stackItem);\n  }\n  /**\n   * Start building a table cell.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.maxColumnWidth]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */\n\n\n  openTableCell() {\n    let {\n      maxColumnWidth = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!(this._stackItem instanceof TableRowStackItem)) {\n      throw new Error('Can\\'t add a table cell to something that is not a table row! Check the formatter.');\n    }\n\n    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n  }\n  /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.colspan] How many columns this cell should occupy.\n   * @param { number } [param0.rowspan] How many rows this cell should occupy.\n   */\n\n\n  closeTableCell() {\n    let {\n      colspan = 1,\n      rowspan = 1\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const cell = this._popStackItem();\n\n    const text = trimCharacter(getText(cell), '\\n');\n    cell.next.cells.push({\n      colspan: colspan,\n      rowspan: rowspan,\n      text: text\n    });\n  }\n  /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */\n\n\n  closeTableRow() {\n    const row = this._popStackItem();\n\n    row.next.rows.push(row.cells);\n  }\n  /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the table.\n   *\n   * @param { TablePrinter } param0.tableToString\n   * A function to convert a table of stringified cells into a complete table.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   */\n\n\n  closeTable(_ref) {\n    let {\n      tableToString,\n      leadingLineBreaks = 2,\n      trailingLineBreaks = 2\n    } = _ref;\n\n    const table = this._popStackItem();\n\n    const output = tableToString(table.rows);\n\n    if (output) {\n      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n  /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */\n\n\n  toString() {\n    return getText(this._stackItem.getRoot()); // There should only be the root item if everything is closed properly.\n  }\n\n}\n\nfunction getText(stackItem) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks, list items and table cells can be requested for text contents.');\n  }\n\n  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\n\nfunction addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks, list items and table cells can contain text.');\n  }\n\n  const parentText = getText(stackItem);\n  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n/**\n * @param { string } str A string to transform.\n * @param { TransformerStackItem } transformer A transformer item (with possible continuation).\n * @returns { string }\n */\n\n\nfunction applyTransformer(str, transformer) {\n  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;\n}\n/**\n * Compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */\n\n\nfunction compile$1() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const selectorsWithoutFormat = options.selectors.filter(s => !s.format);\n\n  if (selectorsWithoutFormat.length) {\n    throw new Error('Following selectors have no specified format: ' + selectorsWithoutFormat.map(s => `\\`${s.selector}\\``).join(', '));\n  }\n\n  const picker = new DecisionTree(options.selectors.map(s => [s.selector, s])).build(hp2Builder);\n\n  if (typeof options.encodeCharacters !== 'function') {\n    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);\n  }\n\n  const baseSelectorsPicker = new DecisionTree(options.baseElements.selectors.map((s, i) => [s, i + 1])).build(hp2Builder);\n\n  function findBaseElements(dom) {\n    return findBases(dom, options, baseSelectorsPicker);\n  }\n\n  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function (dom, builder) {\n    builder.addInline(options.limits.ellipsis || '');\n  });\n  return function (html) {\n    let metadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    return process(html, metadata, options, picker, findBaseElements, limitedWalk);\n  };\n}\n/**\n * Convert given HTML according to preprocessed options.\n *\n * @param { string } html HTML content to convert.\n * @param { any } metadata Optional metadata for HTML document, for use in formatters.\n * @param { Options } options HtmlToText options (preprocessed).\n * @param { import('selderee').Picker<DomNode, TagDefinition> } picker\n * Tag definition picker for DOM nodes processing.\n * @param { (dom: DomNode[]) => DomNode[] } findBaseElements\n * Function to extract elements from HTML DOM\n * that will only be present in the output text.\n * @param { RecursiveCallback } walk Recursive callback.\n * @returns { string }\n */\n\n\nfunction process(html, metadata, options, picker, findBaseElements, walk) {\n  const maxInputLength = options.limits.maxInputLength;\n\n  if (maxInputLength && html && html.length > maxInputLength) {\n    console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);\n    html = html.substring(0, maxInputLength);\n  }\n\n  const document = parseDocument(html, {\n    decodeEntities: options.decodeEntities\n  });\n  const bases = findBaseElements(document.children);\n  const builder = new BlockTextBuilder(options, picker, metadata);\n  walk(bases, builder);\n  return builder.toString();\n}\n\nfunction findBases(dom, options, baseSelectorsPicker) {\n  const results = [];\n\n  function recursiveWalk(walk,\n  /** @type { DomNode[] } */\n  dom) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n\n    for (const elem of dom) {\n      if (elem.type !== 'tag') {\n        continue;\n      }\n\n      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);\n\n      if (pickedSelectorIndex > 0) {\n        results.push({\n          selectorIndex: pickedSelectorIndex,\n          element: elem\n        });\n      } else if (elem.children) {\n        walk(elem.children);\n      }\n\n      if (results.length >= options.limits.maxBaseElements) {\n        return;\n      }\n    }\n  }\n\n  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);\n  limitedWalk(dom);\n\n  if (options.baseElements.orderBy !== 'occurrence') {\n    // 'selectors'\n    results.sort((a, b) => a.selectorIndex - b.selectorIndex);\n  }\n\n  return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map(x => x.element);\n}\n/**\n * Function to walk through DOM nodes and accumulate their string representations.\n *\n * @param   { RecursiveCallback } walk    Recursive callback.\n * @param   { DomNode[] }         [dom]   Nodes array to process.\n * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.\n * @private\n */\n\n\nfunction recursiveWalk(walk, dom, builder) {\n  if (!dom) {\n    return;\n  }\n\n  const options = builder.options;\n  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;\n\n  if (tooManyChildNodes) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    dom.push({\n      data: options.limits.ellipsis,\n      type: 'text'\n    });\n  }\n\n  for (const elem of dom) {\n    switch (elem.type) {\n      case 'text':\n        {\n          builder.addInline(elem.data);\n          break;\n        }\n\n      case 'tag':\n        {\n          const tagDefinition = builder.picker.pick1(elem);\n          const format = options.formatters[tagDefinition.format];\n          format(elem, walk, builder, tagDefinition.options || {});\n          break;\n        }\n    }\n  }\n\n  return;\n}\n/**\n * @param { Object<string,string | false> } dict\n * A dictionary where keys are characters to replace\n * and values are replacement strings.\n *\n * First code point from dict keys is used.\n * Compound emojis with ZWJ are not supported (not until Node 16).\n *\n * @returns { ((str: string) => string) | undefined }\n */\n\n\nfunction makeReplacerFromDict(dict) {\n  if (!dict || Object.keys(dict).length === 0) {\n    return undefined;\n  }\n  /** @type { [string, string][] } */\n\n\n  const entries = Object.entries(dict).filter(_ref2 => {\n    let [, v] = _ref2;\n    return v !== false;\n  });\n  const regex = new RegExp(entries.map(_ref3 => {\n    let [c] = _ref3;\n    return `(${unicodeEscape([...c][0])})`;\n  }).join('|'), 'g');\n  const values = entries.map(_ref4 => {\n    let [, v] = _ref4;\n    return v;\n  });\n\n  const replacer = function (m) {\n    for (var _len3 = arguments.length, cgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      cgs[_key3 - 1] = arguments[_key3];\n    }\n\n    return values[cgs.findIndex(cg => cg)];\n  };\n\n  return str => str.replace(regex, replacer);\n}\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatSkip(elem, walk, builder, formatOptions) {\n  /* do nothing */\n}\n/**\n * Insert the given string literal inline instead of a tag.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatInlineString(elem, walk, builder, formatOptions) {\n  builder.addLiteral(formatOptions.string || '');\n}\n/**\n * Insert a block with the given string literal instead of a tag.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatBlockString(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.addLiteral(formatOptions.string || '');\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatInline(elem, walk, builder, formatOptions) {\n  walk(elem.children, builder);\n}\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatBlock$1(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\nfunction renderOpenTag(elem) {\n  const attrs = elem.attribs && elem.attribs.length ? ' ' + Object.entries(elem.attribs).map(_ref5 => {\n    let [k, v] = _ref5;\n    return v === '' ? k : `${k}=${v.replace(/\"/g, '&quot;')}`;\n  }).join(' ') : '';\n  return `<${elem.name}${attrs}>`;\n}\n\nfunction renderCloseTag(elem) {\n  return `</${elem.name}>`;\n}\n/**\n * Render an element as inline HTML tag, walk through it's children.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatInlineTag(elem, walk, builder, formatOptions) {\n  builder.startNoWrap();\n  builder.addLiteral(renderOpenTag(elem));\n  builder.stopNoWrap();\n  walk(elem.children, builder);\n  builder.startNoWrap();\n  builder.addLiteral(renderCloseTag(elem));\n  builder.stopNoWrap();\n}\n/**\n * Render an element as HTML block bag, walk through it's children.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatBlockTag(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.startNoWrap();\n  builder.addLiteral(renderOpenTag(elem));\n  builder.stopNoWrap();\n  walk(elem.children, builder);\n  builder.startNoWrap();\n  builder.addLiteral(renderCloseTag(elem));\n  builder.stopNoWrap();\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Render an element with all it's children as inline HTML.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatInlineHtml(elem, walk, builder, formatOptions) {\n  builder.startNoWrap();\n  builder.addLiteral(render(elem, {\n    decodeEntities: builder.options.decodeEntities\n  }));\n  builder.stopNoWrap();\n}\n/**\n * Render an element with all it's children as HTML block.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatBlockHtml(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.startNoWrap();\n  builder.addLiteral(render(elem, {\n    decodeEntities: builder.options.decodeEntities\n  }));\n  builder.stopNoWrap();\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Render inline element wrapped with given strings.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatInlineSurround(elem, walk, builder, formatOptions) {\n  builder.addLiteral(formatOptions.prefix || '');\n  walk(elem.children, builder);\n  builder.addLiteral(formatOptions.suffix || '');\n}\n\nvar genericFormatters = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  block: formatBlock$1,\n  blockHtml: formatBlockHtml,\n  blockString: formatBlockString,\n  blockTag: formatBlockTag,\n  inline: formatInline,\n  inlineHtml: formatInlineHtml,\n  inlineString: formatInlineString,\n  inlineSurround: formatInlineSurround,\n  inlineTag: formatInlineTag,\n  skip: formatSkip\n});\n\nfunction getRow(matrix, j) {\n  if (!matrix[j]) {\n    matrix[j] = [];\n  }\n\n  return matrix[j];\n}\n\nfunction findFirstVacantIndex(row) {\n  let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  while (row[x]) {\n    x++;\n  }\n\n  return x;\n}\n\nfunction transposeInPlace(matrix, maxSize) {\n  for (let i = 0; i < maxSize; i++) {\n    const rowI = getRow(matrix, i);\n\n    for (let j = 0; j < i; j++) {\n      const rowJ = getRow(matrix, j);\n      const temp = rowI[j];\n      rowI[j] = rowJ[i];\n      rowJ[i] = temp;\n    }\n  }\n}\n\nfunction putCellIntoLayout(cell, layout, baseRow, baseCol) {\n  for (let r = 0; r < cell.rowspan; r++) {\n    const layoutRow = getRow(layout, baseRow + r);\n\n    for (let c = 0; c < cell.colspan; c++) {\n      layoutRow[baseCol + c] = cell;\n    }\n  }\n}\n\nfunction updateOffset(offsets, base, span, value) {\n  offsets[base + span] = Math.max(offsets[base + span] || 0, offsets[base] + value);\n}\n/**\n * Render a table into a string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */\n\n\nfunction tableToString(tableRows, rowSpacing, colSpacing) {\n  const layout = [];\n  let colNumber = 0;\n  const rowNumber = tableRows.length;\n  const rowOffsets = [0]; // Fill the layout table and row offsets row-by-row.\n\n  for (let j = 0; j < rowNumber; j++) {\n    const layoutRow = getRow(layout, j);\n    const cells = tableRows[j];\n    let x = 0;\n\n    for (let i = 0; i < cells.length; i++) {\n      const cell = cells[i];\n      x = findFirstVacantIndex(layoutRow, x);\n      putCellIntoLayout(cell, layout, j, x);\n      x += cell.colspan;\n      cell.lines = cell.text.split('\\n');\n      const cellHeight = cell.lines.length;\n      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n    }\n\n    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;\n  }\n\n  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);\n  const outputLines = [];\n  const colOffsets = [0]; // Fill column offsets and output lines column-by-column.\n\n  for (let x = 0; x < colNumber; x++) {\n    let y = 0;\n    let cell;\n\n    while (y < rowNumber && (cell = layout[x][y])) {\n      if (!cell.rendered) {\n        let cellWidth = 0;\n\n        for (let j = 0; j < cell.lines.length; j++) {\n          const line = cell.lines[j];\n          const lineOffset = rowOffsets[y] + j;\n          outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;\n          cellWidth = line.length > cellWidth ? line.length : cellWidth;\n        }\n\n        updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n        cell.rendered = true;\n      }\n\n      y += cell.rowspan;\n    }\n  }\n\n  return outputLines.join('\\n');\n}\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatLineBreak(elem, walk, builder, formatOptions) {\n  builder.addLineBreak();\n}\n/**\n * Process a `wbr` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatWbr(elem, walk, builder, formatOptions) {\n  builder.addWordBreakOpportunity();\n}\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatHorizontalLine(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatParagraph(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatPre(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    isPre: true,\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatHeading(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n\n  if (formatOptions.uppercase !== false) {\n    builder.pushWordTransform(str => str.toUpperCase());\n    walk(elem.children, builder);\n    builder.popWordTransform();\n  } else {\n    walk(elem.children, builder);\n  }\n\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatBlockquote(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n    reservedLineLength: 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n    blockTransform: str => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, '\\n') : str).split('\\n').map(line => '> ' + line).join('\\n')\n  });\n}\n\nfunction withBrackets(str, brackets) {\n  if (!brackets) {\n    return str;\n  }\n\n  const lbr = typeof brackets[0] === 'string' ? brackets[0] : '[';\n  const rbr = typeof brackets[1] === 'string' ? brackets[1] : ']';\n  return lbr + str + rbr;\n}\n\nfunction pathRewrite(path, rewriter, baseUrl, metadata, elem) {\n  const modifiedPath = typeof rewriter === 'function' ? rewriter(path, metadata, elem) : path;\n  return modifiedPath[0] === '/' && baseUrl ? trimCharacterEnd(baseUrl, '/') + modifiedPath : modifiedPath;\n}\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatImage(elem, walk, builder, formatOptions) {\n  const attribs = elem.attribs || {};\n  const alt = attribs.alt ? attribs.alt : '';\n  const src = !attribs.src ? '' : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n  const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + ' ' + withBrackets(src, formatOptions.linkBrackets);\n  builder.addInline(text, {\n    noWordTransform: true\n  });\n}\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatAnchor(elem, walk, builder, formatOptions) {\n  function getHref() {\n    if (formatOptions.ignoreHref) {\n      return '';\n    }\n\n    if (!elem.attribs || !elem.attribs.href) {\n      return '';\n    }\n\n    let href = elem.attribs.href.replace(/^mailto:/, '');\n\n    if (formatOptions.noAnchorUrl && href[0] === '#') {\n      return '';\n    }\n\n    href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n    return href;\n  }\n\n  const href = getHref();\n\n  if (!href) {\n    walk(elem.children, builder);\n  } else {\n    let text = '';\n    builder.pushWordTransform(str => {\n      if (str) {\n        text += str;\n      }\n\n      return str;\n    });\n    walk(elem.children, builder);\n    builder.popWordTransform();\n    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n\n    if (!hideSameLink) {\n      builder.addInline(!text ? href : ' ' + withBrackets(href, formatOptions.linkBrackets), {\n        noWordTransform: true\n      });\n    }\n  }\n}\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.\n */\n\n\nfunction formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {\n  const isNestedList = get(elem, ['parent', 'name']) === 'li'; // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n  // so the dumb length comparison is the most robust way to get the correct value.\n\n  let maxPrefixLength = 0;\n  const listItems = (elem.children || [] // it might be more accurate to check only for html spaces here, but no significant benefit\n  ).filter(child => child.type !== 'text' || !/^\\s*$/.test(child.data)).map(function (child) {\n    if (child.name !== 'li') {\n      return {\n        node: child,\n        prefix: ''\n      };\n    }\n\n    const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();\n\n    if (prefix.length > maxPrefixLength) {\n      maxPrefixLength = prefix.length;\n    }\n\n    return {\n      node: child,\n      prefix: prefix\n    };\n  });\n\n  if (!listItems.length) {\n    return;\n  }\n\n  builder.openList({\n    interRowLineBreaks: 1,\n    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,\n    maxPrefixLength: maxPrefixLength,\n    prefixAlign: 'left'\n  });\n\n  for (const {\n    node,\n    prefix\n  } of listItems) {\n    builder.openListItem({\n      prefix: prefix\n    });\n    walk([node], builder);\n    builder.closeListItem();\n  }\n\n  builder.closeList({\n    trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatUnorderedList(elem, walk, builder, formatOptions) {\n  const prefix = formatOptions.itemPrefix || ' * ';\n  return formatList(elem, walk, builder, formatOptions, () => prefix);\n}\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatOrderedList(elem, walk, builder, formatOptions) {\n  let nextIndex = Number(elem.attribs.start || '1');\n  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n\n  const nextPrefixCallback = () => ' ' + indexFunction(nextIndex++) + '. ';\n\n  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */\n\n\nfunction getOrderedListIndexFunction() {\n  let olType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '1';\n\n  switch (olType) {\n    case 'a':\n      return i => numberToLetterSequence(i, 'a');\n\n    case 'A':\n      return i => numberToLetterSequence(i, 'A');\n\n    case 'i':\n      return i => numberToRoman(i).toLowerCase();\n\n    case 'I':\n      return i => numberToRoman(i);\n\n    case '1':\n    default:\n      return i => i.toString();\n  }\n}\n/**\n * Given a list of class and ID selectors (prefixed with '.' and '#'),\n * return them as separate lists of names without prefixes.\n *\n * @param { string[] } selectors Class and ID selectors (`[\".class\", \"#id\"]` etc).\n * @returns { { classes: string[], ids: string[] } }\n */\n\n\nfunction splitClassesAndIds(selectors) {\n  const classes = [];\n  const ids = [];\n\n  for (const selector of selectors) {\n    if (selector.startsWith('.')) {\n      classes.push(selector.substring(1));\n    } else if (selector.startsWith('#')) {\n      ids.push(selector.substring(1));\n    }\n  }\n\n  return {\n    classes: classes,\n    ids: ids\n  };\n}\n\nfunction isDataTable(attr, tables) {\n  if (tables === true) {\n    return true;\n  }\n\n  if (!attr) {\n    return false;\n  }\n\n  const {\n    classes,\n    ids\n  } = splitClassesAndIds(tables);\n  const attrClasses = (attr['class'] || '').split(' ');\n  const attrIds = (attr['id'] || '').split(' ');\n  return attrClasses.some(x => classes.includes(x)) || attrIds.some(x => ids.includes(x));\n}\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatTable(elem, walk, builder, formatOptions) {\n  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);\n}\n\nfunction formatBlock(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n}\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatDataTable(elem, walk, builder, formatOptions) {\n  builder.openTable();\n  elem.children.forEach(walkTable);\n  builder.closeTable({\n    tableToString: rows => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),\n    leadingLineBreaks: formatOptions.leadingLineBreaks,\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n\n  function formatCell(cellNode) {\n    const colspan = +get(cellNode, ['attribs', 'colspan']) || 1;\n    const rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;\n    builder.openTableCell({\n      maxColumnWidth: formatOptions.maxColumnWidth\n    });\n    walk(cellNode.children, builder);\n    builder.closeTableCell({\n      colspan: colspan,\n      rowspan: rowspan\n    });\n  }\n\n  function walkTable(elem) {\n    if (elem.type !== 'tag') {\n      return;\n    }\n\n    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? cellNode => {\n      builder.pushWordTransform(str => str.toUpperCase());\n      formatCell(cellNode);\n      builder.popWordTransform();\n    } : formatCell;\n\n    switch (elem.name) {\n      case 'thead':\n      case 'tbody':\n      case 'tfoot':\n      case 'center':\n        elem.children.forEach(walkTable);\n        return;\n\n      case 'tr':\n        {\n          builder.openTableRow();\n\n          for (const childOfTr of elem.children) {\n            if (childOfTr.type !== 'tag') {\n              continue;\n            }\n\n            switch (childOfTr.name) {\n              case 'th':\n                {\n                  formatHeaderCell(childOfTr);\n                  break;\n                }\n\n              case 'td':\n                {\n                  formatCell(childOfTr);\n                  break;\n                }\n              // do nothing\n            }\n          }\n\n          builder.closeTableRow();\n          break;\n        }\n      // do nothing\n    }\n  }\n}\n\nvar textFormatters = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  anchor: formatAnchor,\n  blockquote: formatBlockquote,\n  dataTable: formatDataTable,\n  heading: formatHeading,\n  horizontalLine: formatHorizontalLine,\n  image: formatImage,\n  lineBreak: formatLineBreak,\n  orderedList: formatOrderedList,\n  paragraph: formatParagraph,\n  pre: formatPre,\n  table: formatTable,\n  unorderedList: formatUnorderedList,\n  wbr: formatWbr\n});\n/**\n * Default options.\n *\n * @constant\n * @type { Options }\n * @default\n * @private\n */\n\nconst DEFAULT_OPTIONS = {\n  baseElements: {\n    selectors: ['body'],\n    orderBy: 'selectors',\n    // 'selectors' | 'occurrence'\n    returnDomByDefault: true\n  },\n  decodeEntities: true,\n  encodeCharacters: {},\n  formatters: {},\n  limits: {\n    ellipsis: '...',\n    maxBaseElements: undefined,\n    maxChildNodes: undefined,\n    maxDepth: undefined,\n    maxInputLength: 1 << 24 // 16_777_216\n\n  },\n  longWordSplit: {\n    forceWrapOnLimit: false,\n    wrapCharacters: []\n  },\n  preserveNewlines: false,\n  selectors: [{\n    selector: '*',\n    format: 'inline'\n  }, {\n    selector: 'a',\n    format: 'anchor',\n    options: {\n      baseUrl: null,\n      hideLinkHrefIfSameAsText: false,\n      ignoreHref: false,\n      linkBrackets: ['[', ']'],\n      noAnchorUrl: true\n    }\n  }, {\n    selector: 'article',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'aside',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'blockquote',\n    format: 'blockquote',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2,\n      trimEmptyLines: true\n    }\n  }, {\n    selector: 'br',\n    format: 'lineBreak'\n  }, {\n    selector: 'div',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'footer',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'form',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'h1',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 3,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h2',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 3,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h3',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 3,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h4',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h5',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h6',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'header',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'hr',\n    format: 'horizontalLine',\n    options: {\n      leadingLineBreaks: 2,\n      length: undefined,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'img',\n    format: 'image',\n    options: {\n      baseUrl: null,\n      linkBrackets: ['[', ']']\n    }\n  }, {\n    selector: 'main',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'nav',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'ol',\n    format: 'orderedList',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'p',\n    format: 'paragraph',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'pre',\n    format: 'pre',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'section',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'table',\n    format: 'table',\n    options: {\n      colSpacing: 3,\n      leadingLineBreaks: 2,\n      maxColumnWidth: 60,\n      rowSpacing: 0,\n      trailingLineBreaks: 2,\n      uppercaseHeaderCells: true\n    }\n  }, {\n    selector: 'ul',\n    format: 'unorderedList',\n    options: {\n      itemPrefix: ' * ',\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'wbr',\n    format: 'wbr'\n  }],\n  tables: [],\n  // deprecated\n  whitespaceCharacters: ' \\t\\r\\n\\f\\u200b',\n  wordwrap: 80\n};\n\nconst concatMerge = (acc, src, options) => [...acc, ...src];\n\nconst overwriteMerge = (acc, src, options) => [...src];\n\nconst selectorsMerge = (acc, src, options) => acc.some(s => typeof s === 'object') ? concatMerge(acc, src) // selectors\n: overwriteMerge(acc, src) // baseElements.selectors\n;\n/**\n * Preprocess options, compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options.\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */\n\n\nfunction compile() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  options = merge(DEFAULT_OPTIONS, options, {\n    arrayMerge: overwriteMerge,\n    customMerge: key => key === 'selectors' ? selectorsMerge : undefined\n  });\n  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);\n  options.selectors = mergeDuplicatesPreferLast(options.selectors, s => s.selector);\n  handleDeprecatedOptions(options);\n  return compile$1(options);\n}\n/**\n * Convert given HTML content to plain text string.\n *\n * @param   { string }  html           HTML content to convert.\n * @param   { Options } [options = {}] HtmlToText options.\n * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.\n * @returns { string }                 Plain text string.\n * @static\n *\n * @example\n * const { convert } = require('html-to-text');\n * const text = convert('<h1>Hello World</h1>', {\n *   wordwrap: 130\n * });\n * console.log(text); // HELLO WORLD\n */\n\n\nfunction convert(html) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  return compile(options)(html, metadata);\n}\n/**\n * Map previously existing and now deprecated options to the new options layout.\n * This is a subject for cleanup in major releases.\n *\n * @param { Options } options HtmlToText options.\n */\n\n\nfunction handleDeprecatedOptions(options) {\n  if (options.tags) {\n    const tagDefinitions = Object.entries(options.tags).map(_ref6 => {\n      let [selector, definition] = _ref6;\n      return { ...definition,\n        selector: selector || '*'\n      };\n    });\n    options.selectors.push(...tagDefinitions);\n    options.selectors = mergeDuplicatesPreferLast(options.selectors, s => s.selector);\n  }\n\n  function set(obj, path, value) {\n    const valueKey = path.pop();\n\n    for (const key of path) {\n      let nested = obj[key];\n\n      if (!nested) {\n        nested = {};\n        obj[key] = nested;\n      }\n\n      obj = nested;\n    }\n\n    obj[valueKey] = value;\n  }\n\n  if (options['baseElement']) {\n    const baseElement = options['baseElement'];\n    set(options, ['baseElements', 'selectors'], Array.isArray(baseElement) ? baseElement : [baseElement]);\n  }\n\n  if (options['returnDomByDefault'] !== undefined) {\n    set(options, ['baseElements', 'returnDomByDefault'], options['returnDomByDefault']);\n  }\n\n  for (const definition of options.selectors) {\n    if (definition.format === 'anchor' && get(definition, ['options', 'noLinkBrackets'])) {\n      set(definition, ['options', 'linkBrackets'], false);\n    }\n  }\n}\n\nexport { compile, convert, convert as htmlToText };","map":{"version":3,"names":["hp2Builder","parseDocument","DecisionTree","merge","render","limitedDepthRecursive","n","f","g","undefined","f1","args","trimCharacter","str","char","start","end","length","substring","trimCharacterEnd","unicodeEscape","replace","c","charCodeAt","toString","padStart","mergeDuplicatesPreferLast","items","getKey","map","Map","i","item","key","set","has","get","arrayMerge","overwriteMerge$1","values","reverse","acc","src","options","obj","path","numberToLetterSequence","num","baseChar","base","digits","push","baseCode","String","fromCharCode","join","I","V","numberToRoman","v","repeat","InlineTextBuilder","constructor","maxLineLength","lines","nextLineWords","wordwrap","Number","MAX_VALUE","nextLineAvailableChars","wrapCharacters","forceWrapOnLimit","stashedSpace","wordBreakOpportunity","pushWord","word","noWrap","startNewLine","isLineStart","cost","first","rest","splitLongWord","part","popWord","lastWord","pop","concatWord","concat","Array","from","isEmpty","clear","words","parts","idx","firstLine","remainingChars","splitIndex","lastIndexOf","StackItem","next","getRoot","BlockStackItem","leadingLineBreaks","inlineTextBuilder","rawText","stashedLineBreaks","isPre","isNoWrap","ListStackItem","interRowLineBreaks","maxPrefixLength","prefixAlign","ListItemStackItem","prefix","TableStackItem","rows","TableRowStackItem","cells","TableCellStackItem","maxColumnWidth","TransformerStackItem","transform","charactersToCodes","WhitespaceProcessor","whitespaceChars","preserveNewlines","whitespaceCharacters","whitespaceCodes","leadingWhitespaceRe","RegExp","trailingWhitespaceRe","allWhitespaceOrEmptyRe","newlineOrNonWhitespaceRe","newlineOrNonNewlineStringRe","wordOrNewlineRe","shrinkWrapAdd","text","previouslyStashedSpace","anyMatch","m","exec","testLeadingWhitespace","testTrailingWhitespace","wordRe","addLiteral","test","testContainsWords","countNewlinesNoWords","lastIndex","counter","match","BlockTextBuilder","picker","metadata","whitespaceProcessor","_stackItem","_wordTransformer","pushWordTransform","wordTransform","popWordTransform","startNoWrap","stopNoWrap","_getCombinedWordTransformer","wt","applyTransformer","ce","encodeCharacters","_popStackItem","addLineBreak","addWordBreakOpportunity","addInline","noWordTransform","newlinesNumber","openBlock","reservedLineLength","Math","max","closeBlock","trailingLineBreaks","blockTransform","block","blockText","getText","addText","openList","openListItem","Error","list","prefixLength","closeListItem","listItem","spacing","padEnd","closeList","openTable","openTableRow","openTableCell","closeTableCell","colspan","rowspan","cell","closeTableRow","row","closeTable","tableToString","table","output","stackItem","parentText","lineBreaks","transformer","compile$1","selectorsWithoutFormat","selectors","filter","s","format","selector","build","makeReplacerFromDict","baseSelectorsPicker","baseElements","findBaseElements","dom","findBases","limitedWalk","limits","maxDepth","recursiveWalk","builder","ellipsis","html","process","walk","maxInputLength","console","warn","document","decodeEntities","bases","children","results","slice","maxChildNodes","elem","type","pickedSelectorIndex","pick1","selectorIndex","element","maxBaseElements","orderBy","sort","a","b","returnDomByDefault","x","tooManyChildNodes","data","tagDefinition","formatters","dict","Object","keys","entries","regex","replacer","cgs","findIndex","cg","formatSkip","formatOptions","formatInlineString","string","formatBlockString","formatInline","formatBlock$1","renderOpenTag","attrs","attribs","k","name","renderCloseTag","formatInlineTag","formatBlockTag","formatInlineHtml","formatBlockHtml","formatInlineSurround","suffix","genericFormatters","freeze","__proto__","blockHtml","blockString","blockTag","inline","inlineHtml","inlineString","inlineSurround","inlineTag","skip","getRow","matrix","j","findFirstVacantIndex","transposeInPlace","maxSize","rowI","rowJ","temp","putCellIntoLayout","layout","baseRow","baseCol","r","layoutRow","updateOffset","offsets","span","value","tableRows","rowSpacing","colSpacing","colNumber","rowNumber","rowOffsets","split","cellHeight","outputLines","colOffsets","y","rendered","cellWidth","line","lineOffset","formatLineBreak","formatWbr","formatHorizontalLine","formatParagraph","formatPre","formatHeading","uppercase","toUpperCase","formatBlockquote","trimEmptyLines","withBrackets","brackets","lbr","rbr","pathRewrite","rewriter","baseUrl","modifiedPath","formatImage","alt","linkBrackets","formatAnchor","getHref","ignoreHref","href","noAnchorUrl","hideSameLink","hideLinkHrefIfSameAsText","formatList","nextPrefixCallback","isNestedList","listItems","child","node","trimStart","formatUnorderedList","itemPrefix","formatOrderedList","nextIndex","indexFunction","getOrderedListIndexFunction","olType","toLowerCase","splitClassesAndIds","classes","ids","startsWith","isDataTable","attr","tables","attrClasses","attrIds","some","includes","formatTable","formatDataTable","formatBlock","forEach","walkTable","formatCell","cellNode","formatHeaderCell","uppercaseHeaderCells","childOfTr","textFormatters","anchor","blockquote","dataTable","heading","horizontalLine","image","lineBreak","orderedList","paragraph","pre","unorderedList","wbr","DEFAULT_OPTIONS","longWordSplit","concatMerge","overwriteMerge","selectorsMerge","compile","customMerge","assign","handleDeprecatedOptions","convert","tags","tagDefinitions","definition","valueKey","nested","baseElement","isArray","htmlToText"],"sources":["C:/Users/Damian/Desktop/inynierka/Apka/client/node_modules/html-to-text/lib/html-to-text.mjs"],"sourcesContent":["import { hp2Builder } from '@selderee/plugin-htmlparser2';\nimport { parseDocument } from 'htmlparser2';\nimport { DecisionTree } from 'selderee';\nimport merge from 'deepmerge';\nimport { render } from 'dom-serializer';\n\n/**\n * Make a recursive function that will only run to a given depth\n * and switches to an alternative function at that depth. \\\n * No limitation if `n` is `undefined` (Just wraps `f` in that case).\n *\n * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.\n * @param   { Function }           f   Function that accepts recursive callback as the first argument.\n * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.\n * @returns { Function }\n */\nfunction limitedDepthRecursive (n, f, g = () => undefined) {\n  if (n === undefined) {\n    const f1 = function (...args) { return f(f1, ...args); };\n    return f1;\n  }\n  if (n >= 0) {\n    return function (...args) { return f(limitedDepthRecursive(n - 1, f, g), ...args); };\n  }\n  return g;\n}\n\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from each side.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */\nfunction trimCharacter (str, char) {\n  let start = 0;\n  let end = str.length;\n  while (start < end && str[start] === char) { ++start; }\n  while (end > start && str[end - 1] === char) { --end; }\n  return (start > 0 || end < str.length)\n    ? str.substring(start, end)\n    : str;\n}\n\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from the end only.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */\nfunction trimCharacterEnd (str, char) {\n  let end = str.length;\n  while (end > 0 && str[end - 1] === char) { --end; }\n  return (end < str.length)\n    ? str.substring(0, end)\n    : str;\n}\n\n/**\n * Return a new string will all characters replaced with unicode escape sequences.\n * This extreme kind of escaping can used to be safely compose regular expressions.\n *\n * @param { string } str A string to escape.\n * @returns { string } A string of unicode escape sequences.\n */\nfunction unicodeEscape (str) {\n  return str.replace(/[\\s\\S]/g, c => '\\\\u' + c.charCodeAt().toString(16).padStart(4, '0'));\n}\n\n/**\n * Deduplicate an array by a given key callback.\n * Item properties are merged recursively and with the preference for last defined values.\n * Of items with the same key, merged item takes the place of the last item,\n * others are omitted.\n *\n * @param { any[] } items An array to deduplicate.\n * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.\n * @returns { any[] }\n */\nfunction mergeDuplicatesPreferLast (items, getKey) {\n  const map = new Map();\n  for (let i = items.length; i-- > 0;) {\n    const item = items[i];\n    const key = getKey(item);\n    map.set(\n      key,\n      (map.has(key))\n        ? merge(item, map.get(key), { arrayMerge: overwriteMerge$1 })\n        : item\n    );\n  }\n  return [...map.values()].reverse();\n}\n\nconst overwriteMerge$1 = (acc, src, options) => [...src];\n\n/**\n * Get a nested property from an object.\n *\n * @param   { object }   obj  The object to query for the value.\n * @param   { string[] } path The path to the property.\n * @returns { any }\n */\nfunction get (obj, path) {\n  for (const key of path) {\n    if (!obj) { return undefined; }\n    obj = obj[key];\n  }\n  return obj;\n}\n\n/**\n * Convert a number into alphabetic sequence representation (Sequence without zeroes).\n *\n * For example: `a, ..., z, aa, ..., zz, aaa, ...`.\n *\n * @param   { number } num              Number to convert. Must be >= 1.\n * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.\n * @param   { number } [base = 26]      Number of characters in the sequence.\n * @returns { string }\n */\nfunction numberToLetterSequence (num, baseChar = 'a', base = 26) {\n  const digits = [];\n  do {\n    num -= 1;\n    digits.push(num % base);\n    num = (num / base) >> 0; // quick `floor`\n  } while (num > 0);\n  const baseCode = baseChar.charCodeAt(0);\n  return digits\n    .reverse()\n    .map(n => String.fromCharCode(baseCode + n))\n    .join('');\n}\n\nconst I = ['I', 'X', 'C', 'M'];\nconst V = ['V', 'L', 'D'];\n\n/**\n * Convert a number to it's Roman representation. No large numbers extension.\n *\n * @param   { number } num Number to convert. `0 < num <= 3999`.\n * @returns { string }\n */\nfunction numberToRoman (num) {\n  return [...(num) + '']\n    .map(n => +n)\n    .reverse()\n    .map((v, i) => ((v % 5 < 4)\n      ? (v < 5 ? '' : V[i]) + I[i].repeat(v % 5)\n      : I[i] + (v < 5 ? V[i] : I[i + 1])))\n    .reverse()\n    .join('');\n}\n\n/**\n * Helps to build text from words.\n */\nclass InlineTextBuilder {\n  /**\n   * Creates an instance of InlineTextBuilder.\n   *\n   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.\n   *\n   * @param { Options } options           HtmlToText options.\n   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.\n   */\n  constructor (options, maxLineLength = undefined) {\n    /** @type { string[][] } */\n    this.lines = [];\n    /** @type { string[] }   */\n    this.nextLineWords = [];\n    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;\n    this.nextLineAvailableChars = this.maxLineLength;\n    this.wrapCharacters = get(options, ['longWordSplit', 'wrapCharacters']) || [];\n    this.forceWrapOnLimit = get(options, ['longWordSplit', 'forceWrapOnLimit']) || false;\n\n    this.stashedSpace = false;\n    this.wordBreakOpportunity = false;\n  }\n\n  /**\n   * Add a new word.\n   *\n   * @param { string } word A word to add.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */\n  pushWord (word, noWrap = false) {\n    if (this.nextLineAvailableChars <= 0 && !noWrap) {\n      this.startNewLine();\n    }\n    const isLineStart = this.nextLineWords.length === 0;\n    const cost = word.length + (isLineStart ? 0 : 1);\n    if ((cost <= this.nextLineAvailableChars) || noWrap) { // Fits into available budget\n\n      this.nextLineWords.push(word);\n      this.nextLineAvailableChars -= cost;\n\n    } else { // Does not fit - try to split the word\n\n      // The word is moved to a new line - prefer to wrap between words.\n      const [first, ...rest] = this.splitLongWord(word);\n      if (!isLineStart) { this.startNewLine(); }\n      this.nextLineWords.push(first);\n      this.nextLineAvailableChars -= first.length;\n      for (const part of rest) {\n        this.startNewLine();\n        this.nextLineWords.push(part);\n        this.nextLineAvailableChars -= part.length;\n      }\n\n    }\n  }\n\n  /**\n   * Pop a word from the currently built line.\n   * This doesn't affect completed lines.\n   *\n   * @returns { string }\n   */\n  popWord () {\n    const lastWord = this.nextLineWords.pop();\n    if (lastWord !== undefined) {\n      const isLineStart = this.nextLineWords.length === 0;\n      const cost = lastWord.length + (isLineStart ? 0 : 1);\n      this.nextLineAvailableChars += cost;\n    }\n    return lastWord;\n  }\n\n  /**\n   * Concat a word to the last word already in the builder.\n   * Adds a new word in case there are no words yet in the last line.\n   *\n   * @param { string } word A word to be concatenated.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */\n  concatWord (word, noWrap = false) {\n    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {\n      this.pushWord(word, noWrap);\n      this.wordBreakOpportunity = false;\n    } else {\n      const lastWord = this.popWord();\n      this.pushWord((lastWord) ? lastWord.concat(word) : word, noWrap);\n    }\n  }\n\n  /**\n   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.\n   *\n   * @param { number } n Number of line breaks that will be added to the resulting string.\n   */\n  startNewLine (n = 1) {\n    this.lines.push(this.nextLineWords);\n    if (n > 1) {\n      this.lines.push(...Array.from({ length: n - 1 }, () => []));\n    }\n    this.nextLineWords = [];\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * No words in this builder.\n   *\n   * @returns { boolean }\n   */\n  isEmpty () {\n    return this.lines.length === 0\n        && this.nextLineWords.length === 0;\n  }\n\n  clear () {\n    this.lines.length = 0;\n    this.nextLineWords.length = 0;\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * Join all lines of words inside the InlineTextBuilder into a complete string.\n   *\n   * @returns { string }\n   */\n  toString () {\n    return [...this.lines, this.nextLineWords]\n      .map(words => words.join(' '))\n      .join('\\n');\n  }\n\n  /**\n   * Split a long word up to fit within the word wrap limit.\n   * Use either a character to split looking back from the word wrap limit,\n   * or truncate to the word wrap limit.\n   *\n   * @param   { string }   word Input word.\n   * @returns { string[] }      Parts of the word.\n   */\n  splitLongWord (word) {\n    const parts = [];\n    let idx = 0;\n    while (word.length > this.maxLineLength) {\n\n      const firstLine = word.substring(0, this.maxLineLength);\n      const remainingChars = word.substring(this.maxLineLength);\n\n      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);\n\n      if (splitIndex > -1) { // Found a character to split on\n\n        word = firstLine.substring(splitIndex + 1) + remainingChars;\n        parts.push(firstLine.substring(0, splitIndex + 1));\n\n      } else { // Not found a character to split on\n\n        idx++;\n        if (idx < this.wrapCharacters.length) { // There is next character to try\n\n          word = firstLine + remainingChars;\n\n        } else { // No more characters to try\n\n          if (this.forceWrapOnLimit) {\n            parts.push(firstLine);\n            word = remainingChars;\n            if (word.length > this.maxLineLength) {\n              continue;\n            }\n          } else {\n            word = firstLine + remainingChars;\n          }\n          break;\n\n        }\n\n      }\n\n    }\n    parts.push(word); // Add remaining part to array\n    return parts;\n  }\n}\n\n/* eslint-disable max-classes-per-file */\n\n\nclass StackItem {\n  constructor (next = null) { this.next = next; }\n\n  getRoot () { return (this.next) ? this.next : this; }\n}\n\nclass BlockStackItem extends StackItem {\n  constructor (options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {\n    super(next);\n    this.leadingLineBreaks = leadingLineBreaks;\n    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);\n    this.rawText = '';\n    this.stashedLineBreaks = 0;\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\n\nclass ListStackItem extends BlockStackItem {\n  constructor (\n    options,\n    next = null,\n    {\n      interRowLineBreaks = 1,\n      leadingLineBreaks = 2,\n      maxLineLength = undefined,\n      maxPrefixLength = 0,\n      prefixAlign = 'left',\n    } = {}\n  ) {\n    super(options, next, leadingLineBreaks, maxLineLength);\n    this.maxPrefixLength = maxPrefixLength;\n    this.prefixAlign = prefixAlign;\n    this.interRowLineBreaks = interRowLineBreaks;\n  }\n}\n\nclass ListItemStackItem extends BlockStackItem {\n  constructor (\n    options,\n    next = null,\n    {\n      leadingLineBreaks = 1,\n      maxLineLength = undefined,\n      prefix = '',\n    } = {}\n  ) {\n    super(options, next, leadingLineBreaks, maxLineLength);\n    this.prefix = prefix;\n  }\n}\n\nclass TableStackItem extends StackItem {\n  constructor (next = null) {\n    super(next);\n    this.rows = [];\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\n\nclass TableRowStackItem extends StackItem {\n  constructor (next = null) {\n    super(next);\n    this.cells = [];\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\n\nclass TableCellStackItem extends StackItem {\n  constructor (options, next = null, maxColumnWidth = undefined) {\n    super(next);\n    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);\n    this.rawText = '';\n    this.stashedLineBreaks = 0;\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\n\nclass TransformerStackItem extends StackItem {\n  constructor (next = null, transform) {\n    super(next);\n    this.transform = transform;\n  }\n}\n\nfunction charactersToCodes (str) {\n  return [...str]\n    .map(c => '\\\\u' + c.charCodeAt(0).toString(16).padStart(4, '0'))\n    .join('');\n}\n\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */\nclass WhitespaceProcessor {\n\n  /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */\n  constructor (options) {\n    this.whitespaceChars = (options.preserveNewlines)\n      ? options.whitespaceCharacters.replace(/\\n/g, '')\n      : options.whitespaceCharacters;\n    const whitespaceCodes = charactersToCodes(this.whitespaceChars);\n    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);\n    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);\n    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);\n    this.newlineOrNonWhitespaceRe = new RegExp(`(\\\\n|[^\\\\n${whitespaceCodes}])`, 'g');\n    this.newlineOrNonNewlineStringRe = new RegExp(`(\\\\n|[^\\\\n]+)`, 'g');\n\n    if (options.preserveNewlines) {\n\n      const wordOrNewlineRe = new RegExp(`\\\\n|[^\\\\n${whitespaceCodes}]+`, 'gm');\n\n      /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.\n       */\n      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str), noWrap = false) {\n        if (!text) { return; }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordOrNewlineRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (m[0] === '\\n') {\n            inlineTextBuilder.startNewLine();\n          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n          }\n          while ((m = wordOrNewlineRe.exec(text)) !== null) {\n            if (m[0] === '\\n') {\n              inlineTextBuilder.startNewLine();\n            } else {\n              inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n            }\n          }\n        }\n        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || (this.testTrailingWhitespace(text));\n        // No need to stash a space in case last added item was a new line,\n        // but that won't affect anything later anyway.\n      };\n\n    } else {\n\n      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, 'g');\n\n      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str), noWrap = false) {\n        if (!text) { return; }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n          }\n          while ((m = wordRe.exec(text)) !== null) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          }\n        }\n        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || this.testTrailingWhitespace(text);\n      };\n\n    }\n  }\n\n  /**\n   * Add text with only minimal processing.\n   * Everything between newlines considered a single word.\n   * No whitespace is trimmed.\n   * Not affected by preserveNewlines option - `\\n` always starts a new line.\n   *\n   * `noWrap` argument is `true` by default - this won't start a new line\n   * even if there is not enough space left in the current line.\n   *\n   * @param { string }            text              Input text.\n   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.\n   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.\n   */\n  addLiteral (text, inlineTextBuilder, noWrap = true) {\n    if (!text) { return; }\n    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n    let anyMatch = false;\n    let m = this.newlineOrNonNewlineStringRe.exec(text);\n    if (m) {\n      anyMatch = true;\n      if (m[0] === '\\n') {\n        inlineTextBuilder.startNewLine();\n      } else if (previouslyStashedSpace) {\n        inlineTextBuilder.pushWord(m[0], noWrap);\n      } else {\n        inlineTextBuilder.concatWord(m[0], noWrap);\n      }\n      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {\n        if (m[0] === '\\n') {\n          inlineTextBuilder.startNewLine();\n        } else {\n          inlineTextBuilder.pushWord(m[0], noWrap);\n        }\n      }\n    }\n    inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch);\n  }\n\n  /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testLeadingWhitespace (text) {\n    return this.leadingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text ends with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testTrailingWhitespace (text) {\n    return this.trailingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text contains any non-whitespace characters.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testContainsWords (text) {\n    return !this.allWhitespaceOrEmptyRe.test(text);\n  }\n\n  /**\n   * Return the number of newlines if there are no words.\n   *\n   * If any word is found then return zero regardless of the actual number of newlines.\n   *\n   * @param   { string }  text  Input string.\n   * @returns { number }\n   */\n  countNewlinesNoWords (text) {\n    this.newlineOrNonWhitespaceRe.lastIndex = 0;\n    let counter = 0;\n    let match;\n    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {\n      if (match[0] === '\\n') {\n        counter++;\n      } else {\n        return 0;\n      }\n    }\n    return counter;\n  }\n\n}\n\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\nclass BlockTextBuilder {\n\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.\n   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.\n   */\n  constructor (options, picker, metadata = undefined) {\n    this.options = options;\n    this.picker = picker;\n    this.metadata = metadata;\n    this.whitespaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n    this._wordTransformer = undefined;\n  }\n\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n  pushWordTransform (wordTransform) {\n    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n  }\n\n  /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */\n  popWordTransform () {\n    if (!this._wordTransformer) { return undefined; }\n    const transform = this._wordTransformer.transform;\n    this._wordTransformer = this._wordTransformer.next;\n    return transform;\n  }\n\n  /**\n   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.\n   */\n  startNoWrap () {\n    this._stackItem.isNoWrap = true;\n  }\n\n  /**\n   * Return automatic wrapping to behavior defined by options.\n   */\n  stopNoWrap () {\n    this._stackItem.isNoWrap = false;\n  }\n\n  /** @returns { (str: string) => string } */\n  _getCombinedWordTransformer () {\n    const wt = (this._wordTransformer)\n      ? ((str) => applyTransformer(str, this._wordTransformer))\n      : undefined;\n    const ce = this.options.encodeCharacters;\n    return (wt)\n      ? ((ce) ? (str) => ce(wt(str)) : wt)\n      : ce;\n  }\n\n  _popStackItem () {\n    const item = this._stackItem;\n    this._stackItem = item.next;\n    return item;\n  }\n\n  /**\n   * Add a line break into currently built block.\n   */\n  addLineBreak () {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof ListItemStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += '\\n';\n    } else {\n      this._stackItem.inlineTextBuilder.startNewLine();\n    }\n  }\n\n  /**\n   * Allow to break line in case directly following text will not fit.\n   */\n  addWordBreakOpportunity () {\n    if (\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof ListItemStackItem\n      || this._stackItem instanceof TableCellStackItem\n    ) {\n      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n    }\n  }\n\n  /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object } [param1]\n   * Object holding the parameters of the operation.\n   *\n   * @param { boolean } [param1.noWordTransform]\n   * Ignore word transformers if there are any.\n   * Don't encode characters as well.\n   * (Use this for things like URL addresses).\n   */\n  addInline (str, { noWordTransform = false } = {}) {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof ListItemStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (\n      str.length === 0 || // empty string\n      (\n        this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant\n        !this.whitespaceProcessor.testContainsWords(str) // no words to add\n      )\n    ) { return; }\n\n    if (this.options.preserveNewlines) {\n      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);\n      if (newlinesNumber > 0) {\n        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);\n        // keep stashedLineBreaks unchanged\n        return;\n      }\n    }\n\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n    this.whitespaceProcessor.shrinkWrapAdd(\n      str,\n      this._stackItem.inlineTextBuilder,\n      (noWordTransform) ? undefined : this._getCombinedWordTransformer(),\n      this._stackItem.isNoWrap\n    );\n    this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n  }\n\n  /**\n   * Add a string inline into the currently built block.\n   *\n   * Use this for markup elements that don't have to adhere\n   * to text layout rules.\n   *\n   * @param { string } str Text to add.\n   */\n  addLiteral (str) {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof ListItemStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n\n    if (str.length === 0) { return; }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n    this.whitespaceProcessor.addLiteral(\n      str,\n      this._stackItem.inlineTextBuilder,\n      this._stackItem.isNoWrap\n    );\n    this._stackItem.stashedLineBreaks = 0;\n  }\n\n  /**\n   * Start building a new block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any preceding block.\n   *\n   * @param { number }  [param0.reservedLineLength]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [param0.isPre]\n   * Should HTML whitespace be preserved inside this block.\n   */\n  openBlock ({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {\n    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n    this._stackItem = new BlockStackItem(\n      this.options,\n      this._stackItem,\n      leadingLineBreaks,\n      maxLineLength\n    );\n    if (isPre) { this._stackItem.isPre = true; }\n  }\n\n  /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [param0.blockTransform]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   */\n  closeBlock ({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {\n    const block = this._popStackItem();\n    const blockText = (blockTransform) ? blockTransform(getText(block)) : getText(block);\n    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n  }\n\n  /**\n   * Start building a new list.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.maxPrefixLength]\n   * Length of the longest list item prefix.\n   * If not supplied or too small then list items won't be aligned properly.\n   *\n   * @param { 'left' | 'right' } [param0.prefixAlign]\n   * Specify how prefixes of different lengths have to be aligned\n   * within a column.\n   *\n   * @param { number } [param0.interRowLineBreaks]\n   * Minimum number of line breaks between list items.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any preceding block.\n   */\n  openList ({ maxPrefixLength = 0, prefixAlign = 'left', interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {\n    this._stackItem = new ListStackItem(this.options, this._stackItem, {\n      interRowLineBreaks: interRowLineBreaks,\n      leadingLineBreaks: leadingLineBreaks,\n      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,\n      maxPrefixLength: maxPrefixLength,\n      prefixAlign: prefixAlign\n    });\n  }\n\n  /**\n   * Start building a new list item.\n   *\n   * @param {object} param0\n   * Object holding the parameters of the list item.\n   *\n   * @param { string } [param0.prefix]\n   * Prefix for this list item (item number, bullet point, etc).\n   */\n  openListItem ({ prefix = '' } = {}) {\n    if (!(this._stackItem instanceof ListStackItem)) {\n      throw new Error('Can\\'t add a list item to something that is not a list! Check the formatter.');\n    }\n    const list = this._stackItem;\n    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);\n    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);\n    this._stackItem = new ListItemStackItem(this.options, list, {\n      prefix: prefix,\n      maxLineLength: maxLineLength,\n      leadingLineBreaks: list.interRowLineBreaks\n    });\n  }\n\n  /**\n   * Finalize currently built list item, add it's content to the parent list.\n   */\n  closeListItem () {\n    const listItem = this._popStackItem();\n    const list = listItem.next;\n\n    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);\n    const spacing = '\\n' + ' '.repeat(prefixLength);\n    const prefix = (list.prefixAlign === 'right')\n      ? listItem.prefix.padStart(prefixLength)\n      : listItem.prefix.padEnd(prefixLength);\n    const text = prefix + getText(listItem).replace(/\\n/g, spacing);\n\n    addText(\n      list,\n      text,\n      listItem.leadingLineBreaks,\n      Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks)\n    );\n  }\n\n  /**\n   * Finalize currently built list, add it's content to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any following block.\n   */\n  closeList ({ trailingLineBreaks = 2 } = {}) {\n    const list = this._popStackItem();\n    const text = getText(list);\n    if (text) {\n      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Start building a table.\n   */\n  openTable () {\n    this._stackItem = new TableStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table row.\n   */\n  openTableRow () {\n    if (!(this._stackItem instanceof TableStackItem)) {\n      throw new Error('Can\\'t add a table row to something that is not a table! Check the formatter.');\n    }\n    this._stackItem = new TableRowStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table cell.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.maxColumnWidth]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */\n  openTableCell ({ maxColumnWidth = undefined } = {}) {\n    if (!(this._stackItem instanceof TableRowStackItem)) {\n      throw new Error('Can\\'t add a table cell to something that is not a table row! Check the formatter.');\n    }\n    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n  }\n\n  /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.colspan] How many columns this cell should occupy.\n   * @param { number } [param0.rowspan] How many rows this cell should occupy.\n   */\n  closeTableCell ({ colspan = 1, rowspan = 1 } = {}) {\n    const cell = this._popStackItem();\n    const text = trimCharacter(getText(cell), '\\n');\n    cell.next.cells.push({ colspan: colspan, rowspan: rowspan, text: text });\n  }\n\n  /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */\n  closeTableRow () {\n    const row = this._popStackItem();\n    row.next.rows.push(row.cells);\n  }\n\n  /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the table.\n   *\n   * @param { TablePrinter } param0.tableToString\n   * A function to convert a table of stringified cells into a complete table.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   */\n  closeTable ({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {\n    const table = this._popStackItem();\n    const output = tableToString(table.rows);\n    if (output) {\n      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */\n  toString () {\n    return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n  }\n\n}\n\nfunction getText (stackItem) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof ListItemStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks, list items and table cells can be requested for text contents.');\n  }\n  return (stackItem.inlineTextBuilder.isEmpty())\n    ? stackItem.rawText\n    : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\n\nfunction addText (stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof ListItemStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks, list items and table cells can contain text.');\n  }\n  const parentText = getText(stackItem);\n  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n\n/**\n * @param { string } str A string to transform.\n * @param { TransformerStackItem } transformer A transformer item (with possible continuation).\n * @returns { string }\n */\nfunction applyTransformer (str, transformer) {\n  return ((transformer) ? applyTransformer(transformer.transform(str), transformer.next) : str);\n}\n\n/**\n * Compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */\nfunction compile$1 (options = {}) {\n  const selectorsWithoutFormat = options.selectors.filter(s => !s.format);\n  if (selectorsWithoutFormat.length) {\n    throw new Error(\n      'Following selectors have no specified format: ' +\n      selectorsWithoutFormat.map(s => `\\`${s.selector}\\``).join(', ')\n    );\n  }\n  const picker = new DecisionTree(\n    options.selectors.map(s => [s.selector, s])\n  ).build(hp2Builder);\n\n  if (typeof options.encodeCharacters !== 'function') {\n    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);\n  }\n\n  const baseSelectorsPicker = new DecisionTree(\n    options.baseElements.selectors.map((s, i) => [s, i + 1])\n  ).build(hp2Builder);\n  function findBaseElements (dom) {\n    return findBases(dom, options, baseSelectorsPicker);\n  }\n\n  const limitedWalk = limitedDepthRecursive(\n    options.limits.maxDepth,\n    recursiveWalk,\n    function (dom, builder) {\n      builder.addInline(options.limits.ellipsis || '');\n    }\n  );\n\n  return function (html, metadata = undefined) {\n    return process(html, metadata, options, picker, findBaseElements, limitedWalk);\n  };\n}\n\n\n/**\n * Convert given HTML according to preprocessed options.\n *\n * @param { string } html HTML content to convert.\n * @param { any } metadata Optional metadata for HTML document, for use in formatters.\n * @param { Options } options HtmlToText options (preprocessed).\n * @param { import('selderee').Picker<DomNode, TagDefinition> } picker\n * Tag definition picker for DOM nodes processing.\n * @param { (dom: DomNode[]) => DomNode[] } findBaseElements\n * Function to extract elements from HTML DOM\n * that will only be present in the output text.\n * @param { RecursiveCallback } walk Recursive callback.\n * @returns { string }\n */\nfunction process (html, metadata, options, picker, findBaseElements, walk) {\n  const maxInputLength = options.limits.maxInputLength;\n  if (maxInputLength && html && html.length > maxInputLength) {\n    console.warn(\n      `Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`\n    );\n    html = html.substring(0, maxInputLength);\n  }\n\n  const document = parseDocument(html, { decodeEntities: options.decodeEntities });\n  const bases = findBaseElements(document.children);\n  const builder = new BlockTextBuilder(options, picker, metadata);\n  walk(bases, builder);\n  return builder.toString();\n}\n\n\nfunction findBases (dom, options, baseSelectorsPicker) {\n  const results = [];\n\n  function recursiveWalk (walk, /** @type { DomNode[] } */ dom) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    for (const elem of dom) {\n      if (elem.type !== 'tag') {\n        continue;\n      }\n      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);\n      if (pickedSelectorIndex > 0) {\n        results.push({ selectorIndex: pickedSelectorIndex, element: elem });\n      } else if (elem.children) {\n        walk(elem.children);\n      }\n      if (results.length >= options.limits.maxBaseElements) {\n        return;\n      }\n    }\n  }\n\n  const limitedWalk = limitedDepthRecursive(\n    options.limits.maxDepth,\n    recursiveWalk\n  );\n  limitedWalk(dom);\n\n  if (options.baseElements.orderBy !== 'occurrence') { // 'selectors'\n    results.sort((a, b) => a.selectorIndex - b.selectorIndex);\n  }\n  return (options.baseElements.returnDomByDefault && results.length === 0)\n    ? dom\n    : results.map(x => x.element);\n}\n\n/**\n * Function to walk through DOM nodes and accumulate their string representations.\n *\n * @param   { RecursiveCallback } walk    Recursive callback.\n * @param   { DomNode[] }         [dom]   Nodes array to process.\n * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.\n * @private\n */\nfunction recursiveWalk (walk, dom, builder) {\n  if (!dom) { return; }\n\n  const options = builder.options;\n\n  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;\n  if (tooManyChildNodes) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    dom.push({\n      data: options.limits.ellipsis,\n      type: 'text'\n    });\n  }\n\n  for (const elem of dom) {\n    switch (elem.type) {\n      case 'text': {\n        builder.addInline(elem.data);\n        break;\n      }\n      case 'tag': {\n        const tagDefinition = builder.picker.pick1(elem);\n        const format = options.formatters[tagDefinition.format];\n        format(elem, walk, builder, tagDefinition.options || {});\n        break;\n      }\n    }\n  }\n\n  return;\n}\n\n/**\n * @param { Object<string,string | false> } dict\n * A dictionary where keys are characters to replace\n * and values are replacement strings.\n *\n * First code point from dict keys is used.\n * Compound emojis with ZWJ are not supported (not until Node 16).\n *\n * @returns { ((str: string) => string) | undefined }\n */\nfunction makeReplacerFromDict (dict) {\n  if (!dict || Object.keys(dict).length === 0) {\n    return undefined;\n  }\n  /** @type { [string, string][] } */\n  const entries = Object.entries(dict).filter(([, v]) => v !== false);\n  const regex = new RegExp(\n    entries\n      .map(([c]) => `(${unicodeEscape([...c][0])})`)\n      .join('|'),\n    'g'\n  );\n  const values = entries.map(([, v]) => v);\n  const replacer = (m, ...cgs) => values[cgs.findIndex(cg => cg)];\n  return (str) => str.replace(regex, replacer);\n}\n\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */\nfunction formatSkip (elem, walk, builder, formatOptions) {\n  /* do nothing */\n}\n\n/**\n * Insert the given string literal inline instead of a tag.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineString (elem, walk, builder, formatOptions) {\n  builder.addLiteral(formatOptions.string || '');\n}\n\n/**\n * Insert a block with the given string literal instead of a tag.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockString (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.addLiteral(formatOptions.string || '');\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */\nfunction formatInline (elem, walk, builder, formatOptions) {\n  walk(elem.children, builder);\n}\n\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */\nfunction formatBlock$1 (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\nfunction renderOpenTag (elem) {\n  const attrs = (elem.attribs && elem.attribs.length)\n    ? ' ' + Object.entries(elem.attribs)\n      .map(([k, v]) => ((v === '') ? k : `${k}=${v.replace(/\"/g, '&quot;')}`))\n      .join(' ')\n    : '';\n  return `<${elem.name}${attrs}>`;\n}\n\nfunction renderCloseTag (elem) {\n  return `</${elem.name}>`;\n}\n\n/**\n * Render an element as inline HTML tag, walk through it's children.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineTag (elem, walk, builder, formatOptions) {\n  builder.startNoWrap();\n  builder.addLiteral(renderOpenTag(elem));\n  builder.stopNoWrap();\n  walk(elem.children, builder);\n  builder.startNoWrap();\n  builder.addLiteral(renderCloseTag(elem));\n  builder.stopNoWrap();\n}\n\n/**\n * Render an element as HTML block bag, walk through it's children.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockTag (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.startNoWrap();\n  builder.addLiteral(renderOpenTag(elem));\n  builder.stopNoWrap();\n  walk(elem.children, builder);\n  builder.startNoWrap();\n  builder.addLiteral(renderCloseTag(elem));\n  builder.stopNoWrap();\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Render an element with all it's children as inline HTML.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineHtml (elem, walk, builder, formatOptions) {\n  builder.startNoWrap();\n  builder.addLiteral(\n    render(elem, { decodeEntities: builder.options.decodeEntities })\n  );\n  builder.stopNoWrap();\n}\n\n/**\n * Render an element with all it's children as HTML block.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockHtml (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.startNoWrap();\n  builder.addLiteral(\n    render(elem, { decodeEntities: builder.options.decodeEntities })\n  );\n  builder.stopNoWrap();\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Render inline element wrapped with given strings.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineSurround (elem, walk, builder, formatOptions) {\n  builder.addLiteral(formatOptions.prefix || '');\n  walk(elem.children, builder);\n  builder.addLiteral(formatOptions.suffix || '');\n}\n\nvar genericFormatters = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  block: formatBlock$1,\n  blockHtml: formatBlockHtml,\n  blockString: formatBlockString,\n  blockTag: formatBlockTag,\n  inline: formatInline,\n  inlineHtml: formatInlineHtml,\n  inlineString: formatInlineString,\n  inlineSurround: formatInlineSurround,\n  inlineTag: formatInlineTag,\n  skip: formatSkip\n});\n\nfunction getRow (matrix, j) {\n  if (!matrix[j]) { matrix[j] = []; }\n  return matrix[j];\n}\n\nfunction findFirstVacantIndex (row, x = 0) {\n  while (row[x]) { x++; }\n  return x;\n}\n\nfunction transposeInPlace (matrix, maxSize) {\n  for (let i = 0; i < maxSize; i++) {\n    const rowI = getRow(matrix, i);\n    for (let j = 0; j < i; j++) {\n      const rowJ = getRow(matrix, j);\n      const temp = rowI[j];\n      rowI[j] = rowJ[i];\n      rowJ[i] = temp;\n    }\n  }\n}\n\nfunction putCellIntoLayout (cell, layout, baseRow, baseCol) {\n  for (let r = 0; r < cell.rowspan; r++) {\n    const layoutRow = getRow(layout, baseRow + r);\n    for (let c = 0; c < cell.colspan; c++) {\n      layoutRow[baseCol + c] = cell;\n    }\n  }\n}\n\nfunction updateOffset (offsets, base, span, value) {\n  offsets[base + span] = Math.max(\n    offsets[base + span] || 0,\n    offsets[base] + value\n  );\n}\n\n/**\n * Render a table into a string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */\nfunction tableToString (tableRows, rowSpacing, colSpacing) {\n  const layout = [];\n  let colNumber = 0;\n  const rowNumber = tableRows.length;\n  const rowOffsets = [0];\n  // Fill the layout table and row offsets row-by-row.\n  for (let j = 0; j < rowNumber; j++) {\n    const layoutRow = getRow(layout, j);\n    const cells = tableRows[j];\n    let x = 0;\n    for (let i = 0; i < cells.length; i++) {\n      const cell = cells[i];\n      x = findFirstVacantIndex(layoutRow, x);\n      putCellIntoLayout(cell, layout, j, x);\n      x += cell.colspan;\n      cell.lines = cell.text.split('\\n');\n      const cellHeight = cell.lines.length;\n      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n    }\n    colNumber = (layoutRow.length > colNumber) ? layoutRow.length : colNumber;\n  }\n\n  transposeInPlace(layout, (rowNumber > colNumber) ? rowNumber : colNumber);\n\n  const outputLines = [];\n  const colOffsets = [0];\n  // Fill column offsets and output lines column-by-column.\n  for (let x = 0; x < colNumber; x++) {\n    let y = 0;\n    let cell;\n    while (y < rowNumber && (cell = layout[x][y])) {\n      if (!cell.rendered) {\n        let cellWidth = 0;\n        for (let j = 0; j < cell.lines.length; j++) {\n          const line = cell.lines[j];\n          const lineOffset = rowOffsets[y] + j;\n          outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;\n          cellWidth = (line.length > cellWidth) ? line.length : cellWidth;\n        }\n        updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n        cell.rendered = true;\n      }\n      y += cell.rowspan;\n    }\n  }\n\n  return outputLines.join('\\n');\n}\n\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */\nfunction formatLineBreak (elem, walk, builder, formatOptions) {\n  builder.addLineBreak();\n}\n\n/**\n * Process a `wbr` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */\nfunction formatWbr (elem, walk, builder, formatOptions) {\n  builder.addWordBreakOpportunity();\n}\n\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */\nfunction formatHorizontalLine (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */\nfunction formatParagraph (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */\nfunction formatPre (elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    isPre: true,\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */\nfunction formatHeading (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  if (formatOptions.uppercase !== false) {\n    builder.pushWordTransform(str => str.toUpperCase());\n    walk(elem.children, builder);\n    builder.popWordTransform();\n  } else {\n    walk(elem.children, builder);\n  }\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockquote (elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n    reservedLineLength: 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n    blockTransform: str => ((formatOptions.trimEmptyLines !== false) ? trimCharacter(str, '\\n') : str)\n      .split('\\n')\n      .map(line => '> ' + line)\n      .join('\\n')\n  });\n}\n\nfunction withBrackets (str, brackets) {\n  if (!brackets) { return str; }\n\n  const lbr = (typeof brackets[0] === 'string')\n    ? brackets[0]\n    : '[';\n  const rbr = (typeof brackets[1] === 'string')\n    ? brackets[1]\n    : ']';\n  return lbr + str + rbr;\n}\n\nfunction pathRewrite (path, rewriter, baseUrl, metadata, elem) {\n  const modifiedPath = (typeof rewriter === 'function')\n    ? rewriter(path, metadata, elem)\n    : path;\n  return (modifiedPath[0] === '/' && baseUrl)\n    ? trimCharacterEnd(baseUrl, '/') + modifiedPath\n    : modifiedPath;\n}\n\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */\nfunction formatImage (elem, walk, builder, formatOptions) {\n  const attribs = elem.attribs || {};\n  const alt = (attribs.alt)\n    ? attribs.alt\n    : '';\n  const src = (!attribs.src)\n    ? ''\n    : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n  const text = (!src)\n    ? alt\n    : (!alt)\n      ? withBrackets(src, formatOptions.linkBrackets)\n      : alt + ' ' + withBrackets(src, formatOptions.linkBrackets);\n\n  builder.addInline(text, { noWordTransform: true });\n}\n\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */\nfunction formatAnchor (elem, walk, builder, formatOptions) {\n  function getHref () {\n    if (formatOptions.ignoreHref) { return ''; }\n    if (!elem.attribs || !elem.attribs.href) { return ''; }\n    let href = elem.attribs.href.replace(/^mailto:/, '');\n    if (formatOptions.noAnchorUrl && href[0] === '#') { return ''; }\n    href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n    return href;\n  }\n  const href = getHref();\n  if (!href) {\n    walk(elem.children, builder);\n  } else {\n    let text = '';\n    builder.pushWordTransform(\n      str => {\n        if (str) { text += str; }\n        return str;\n      }\n    );\n    walk(elem.children, builder);\n    builder.popWordTransform();\n\n    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n    if (!hideSameLink) {\n      builder.addInline(\n        (!text)\n          ? href\n          : ' ' + withBrackets(href, formatOptions.linkBrackets),\n        { noWordTransform: true }\n      );\n    }\n  }\n}\n\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.\n */\nfunction formatList (elem, walk, builder, formatOptions, nextPrefixCallback) {\n  const isNestedList = get(elem, ['parent', 'name']) === 'li';\n\n  // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n  // so the dumb length comparison is the most robust way to get the correct value.\n  let maxPrefixLength = 0;\n  const listItems = (elem.children || [])\n    // it might be more accurate to check only for html spaces here, but no significant benefit\n    .filter(child => child.type !== 'text' || !/^\\s*$/.test(child.data))\n    .map(function (child) {\n      if (child.name !== 'li') {\n        return { node: child, prefix: '' };\n      }\n      const prefix = (isNestedList)\n        ? nextPrefixCallback().trimStart()\n        : nextPrefixCallback();\n      if (prefix.length > maxPrefixLength) { maxPrefixLength = prefix.length; }\n      return { node: child, prefix: prefix };\n    });\n  if (!listItems.length) { return; }\n\n  builder.openList({\n    interRowLineBreaks: 1,\n    leadingLineBreaks: isNestedList ? 1 : (formatOptions.leadingLineBreaks || 2),\n    maxPrefixLength: maxPrefixLength,\n    prefixAlign: 'left'\n  });\n\n  for (const { node, prefix } of listItems) {\n    builder.openListItem({ prefix: prefix });\n    walk([node], builder);\n    builder.closeListItem();\n  }\n\n  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : (formatOptions.trailingLineBreaks || 2) });\n}\n\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatUnorderedList (elem, walk, builder, formatOptions) {\n  const prefix = formatOptions.itemPrefix || ' * ';\n  return formatList(elem, walk, builder, formatOptions, () => prefix);\n}\n\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatOrderedList (elem, walk, builder, formatOptions) {\n  let nextIndex = Number(elem.attribs.start || '1');\n  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n  const nextPrefixCallback = () => ' ' + indexFunction(nextIndex++) + '. ';\n  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */\nfunction getOrderedListIndexFunction (olType = '1') {\n  switch (olType) {\n    case 'a': return (i) => numberToLetterSequence(i, 'a');\n    case 'A': return (i) => numberToLetterSequence(i, 'A');\n    case 'i': return (i) => numberToRoman(i).toLowerCase();\n    case 'I': return (i) => numberToRoman(i);\n    case '1':\n    default: return (i) => (i).toString();\n  }\n}\n\n/**\n * Given a list of class and ID selectors (prefixed with '.' and '#'),\n * return them as separate lists of names without prefixes.\n *\n * @param { string[] } selectors Class and ID selectors (`[\".class\", \"#id\"]` etc).\n * @returns { { classes: string[], ids: string[] } }\n */\nfunction splitClassesAndIds (selectors) {\n  const classes = [];\n  const ids = [];\n  for (const selector of selectors) {\n    if (selector.startsWith('.')) {\n      classes.push(selector.substring(1));\n    } else if (selector.startsWith('#')) {\n      ids.push(selector.substring(1));\n    }\n  }\n  return { classes: classes, ids: ids };\n}\n\nfunction isDataTable (attr, tables) {\n  if (tables === true) { return true; }\n  if (!attr) { return false; }\n\n  const { classes, ids } = splitClassesAndIds(tables);\n  const attrClasses = (attr['class'] || '').split(' ');\n  const attrIds = (attr['id'] || '').split(' ');\n\n  return attrClasses.some(x => classes.includes(x)) || attrIds.some(x => ids.includes(x));\n}\n\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */\nfunction formatTable (elem, walk, builder, formatOptions) {\n  return isDataTable(elem.attribs, builder.options.tables)\n    ? formatDataTable(elem, walk, builder, formatOptions)\n    : formatBlock(elem, walk, builder, formatOptions);\n}\n\nfunction formatBlock (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });\n}\n\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */\nfunction formatDataTable (elem, walk, builder, formatOptions) {\n  builder.openTable();\n  elem.children.forEach(walkTable);\n  builder.closeTable({\n    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),\n    leadingLineBreaks: formatOptions.leadingLineBreaks,\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n\n  function formatCell (cellNode) {\n    const colspan = +get(cellNode, ['attribs', 'colspan']) || 1;\n    const rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;\n    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });\n    walk(cellNode.children, builder);\n    builder.closeTableCell({ colspan: colspan, rowspan: rowspan });\n  }\n\n  function walkTable (elem) {\n    if (elem.type !== 'tag') { return; }\n\n    const formatHeaderCell = (formatOptions.uppercaseHeaderCells !== false)\n      ? (cellNode) => {\n        builder.pushWordTransform(str => str.toUpperCase());\n        formatCell(cellNode);\n        builder.popWordTransform();\n      }\n      : formatCell;\n\n    switch (elem.name) {\n      case 'thead':\n      case 'tbody':\n      case 'tfoot':\n      case 'center':\n        elem.children.forEach(walkTable);\n        return;\n\n      case 'tr': {\n        builder.openTableRow();\n        for (const childOfTr of elem.children) {\n          if (childOfTr.type !== 'tag') { continue; }\n          switch (childOfTr.name) {\n            case 'th': {\n              formatHeaderCell(childOfTr);\n              break;\n            }\n            case 'td': {\n              formatCell(childOfTr);\n              break;\n            }\n              // do nothing\n          }\n        }\n        builder.closeTableRow();\n        break;\n      }\n        // do nothing\n    }\n  }\n}\n\nvar textFormatters = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  anchor: formatAnchor,\n  blockquote: formatBlockquote,\n  dataTable: formatDataTable,\n  heading: formatHeading,\n  horizontalLine: formatHorizontalLine,\n  image: formatImage,\n  lineBreak: formatLineBreak,\n  orderedList: formatOrderedList,\n  paragraph: formatParagraph,\n  pre: formatPre,\n  table: formatTable,\n  unorderedList: formatUnorderedList,\n  wbr: formatWbr\n});\n\n/**\n * Default options.\n *\n * @constant\n * @type { Options }\n * @default\n * @private\n */\nconst DEFAULT_OPTIONS = {\n  baseElements: {\n    selectors: [ 'body' ],\n    orderBy: 'selectors', // 'selectors' | 'occurrence'\n    returnDomByDefault: true\n  },\n  decodeEntities: true,\n  encodeCharacters: {},\n  formatters: {},\n  limits: {\n    ellipsis: '...',\n    maxBaseElements: undefined,\n    maxChildNodes: undefined,\n    maxDepth: undefined,\n    maxInputLength: (1 << 24) // 16_777_216\n  },\n  longWordSplit: {\n    forceWrapOnLimit: false,\n    wrapCharacters: []\n  },\n  preserveNewlines: false,\n  selectors: [\n    { selector: '*', format: 'inline' },\n    {\n      selector: 'a',\n      format: 'anchor',\n      options: {\n        baseUrl: null,\n        hideLinkHrefIfSameAsText: false,\n        ignoreHref: false,\n        linkBrackets: ['[', ']'],\n        noAnchorUrl: true\n      }\n    },\n    { selector: 'article', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'aside', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    {\n      selector: 'blockquote',\n      format: 'blockquote',\n      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }\n    },\n    { selector: 'br', format: 'lineBreak' },\n    { selector: 'div', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'footer', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'form', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'h1', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h2', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h3', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h4', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h5', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h6', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'header', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    {\n      selector: 'hr',\n      format: 'horizontalLine',\n      options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }\n    },\n    {\n      selector: 'img',\n      format: 'image',\n      options: { baseUrl: null, linkBrackets: ['[', ']'] }\n    },\n    { selector: 'main', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'nav', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    {\n      selector: 'ol',\n      format: 'orderedList',\n      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }\n    },\n    { selector: 'p', format: 'paragraph', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },\n    { selector: 'pre', format: 'pre', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },\n    { selector: 'section', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    {\n      selector: 'table',\n      format: 'table',\n      options: {\n        colSpacing: 3,\n        leadingLineBreaks: 2,\n        maxColumnWidth: 60,\n        rowSpacing: 0,\n        trailingLineBreaks: 2,\n        uppercaseHeaderCells: true\n      }\n    },\n    {\n      selector: 'ul',\n      format: 'unorderedList',\n      options: { itemPrefix: ' * ', leadingLineBreaks: 2, trailingLineBreaks: 2 }\n    },\n    { selector: 'wbr', format: 'wbr' },\n  ],\n  tables: [], // deprecated\n  whitespaceCharacters: ' \\t\\r\\n\\f\\u200b',\n  wordwrap: 80\n};\n\nconst concatMerge = (acc, src, options) => [...acc, ...src];\nconst overwriteMerge = (acc, src, options) => [...src];\nconst selectorsMerge = (acc, src, options) => (\n  (acc.some(s => typeof s === 'object'))\n    ? concatMerge(acc, src) // selectors\n    : overwriteMerge(acc, src) // baseElements.selectors\n);\n\n/**\n * Preprocess options, compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options.\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */\nfunction compile (options = {}) {\n  options = merge(\n    DEFAULT_OPTIONS,\n    options,\n    {\n      arrayMerge: overwriteMerge,\n      customMerge: (key) => ((key === 'selectors') ? selectorsMerge : undefined)\n    }\n  );\n  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);\n  options.selectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));\n\n  handleDeprecatedOptions(options);\n\n  return compile$1(options);\n}\n\n/**\n * Convert given HTML content to plain text string.\n *\n * @param   { string }  html           HTML content to convert.\n * @param   { Options } [options = {}] HtmlToText options.\n * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.\n * @returns { string }                 Plain text string.\n * @static\n *\n * @example\n * const { convert } = require('html-to-text');\n * const text = convert('<h1>Hello World</h1>', {\n *   wordwrap: 130\n * });\n * console.log(text); // HELLO WORLD\n */\nfunction convert (html, options = {}, metadata = undefined) {\n  return compile(options)(html, metadata);\n}\n\n/**\n * Map previously existing and now deprecated options to the new options layout.\n * This is a subject for cleanup in major releases.\n *\n * @param { Options } options HtmlToText options.\n */\nfunction handleDeprecatedOptions (options) {\n  if (options.tags) {\n    const tagDefinitions = Object.entries(options.tags).map(\n      ([selector, definition]) => ({ ...definition, selector: selector || '*' })\n    );\n    options.selectors.push(...tagDefinitions);\n    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));\n  }\n\n  function set (obj, path, value) {\n    const valueKey = path.pop();\n    for (const key of path) {\n      let nested = obj[key];\n      if (!nested) {\n        nested = {};\n        obj[key] = nested;\n      }\n      obj = nested;\n    }\n    obj[valueKey] = value;\n  }\n\n  if (options['baseElement']) {\n    const baseElement = options['baseElement'];\n    set(\n      options,\n      ['baseElements', 'selectors'],\n      (Array.isArray(baseElement) ? baseElement : [baseElement])\n    );\n  }\n  if (options['returnDomByDefault'] !== undefined) {\n    set(options, ['baseElements', 'returnDomByDefault'], options['returnDomByDefault']);\n  }\n\n  for (const definition of options.selectors) {\n    if (definition.format === 'anchor' && get(definition, ['options', 'noLinkBrackets'])) {\n      set(definition, ['options', 'linkBrackets'], false);\n    }\n  }\n}\n\nexport { compile, convert, convert as htmlToText };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}